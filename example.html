<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI UGC Product Ad Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&family=Kanit:wght@400;500;700&family=Mitr:wght@400;500;700&family=Prompt:wght@400;500;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .video-aspect {
            aspect-ratio: 9 / 16;
        }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .script-details, .collapsible-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .script-details.expanded, .collapsible-container.expanded {
            max-height: 2000px; /* Increased max-height for generation status */
        }
        .chevron-rotated {
            transform: rotate(180deg);
        }
        .score-circle {
            transition: stroke-dasharray 0.5s ease-in-out;
        }
        /* Styles for Upload Modal */
        #youtube-upload-modal, #rendering-loader {
            background-color: rgba(0, 0, 0, 0.7);
        }
        #upload-modal-content {
            background-color: #1f2937; /* bg-gray-800 */
            color: #f3f4f6; /* text-gray-100 */
        }
        .upload-form-label {
            color: #d1d5db; /* text-gray-300 */
        }
        .upload-form-input, .upload-form-select, .upload-form-textarea {
            background-color: #374151; /* bg-gray-700 */
            border-color: #4b5563; /* border-gray-600 */
            color: #f9fafb; /* text-gray-50 */
        }
        .upload-form-input::placeholder, .upload-form-textarea::placeholder {
            color: #9ca3af; /* placeholder-gray-400 */
        }
        .upload-primary-button {
            background-color: #2563eb; /* bg-blue-600 */
            color: #ffffff;
        }
        .upload-primary-button:hover {
            background-color: #1d4ed8; /* bg-blue-700 */
        }
        .upload-primary-button:disabled {
            background-color: #4b5563; /* bg-gray-600 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        .script-variation {
            border: 1px solid #4b5563;
            transition: border-color 0.3s;
        }
        .script-variation.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
        }
        #global-toast {
            transition: transform 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">

    <!-- Global Message Toast -->
    <div id="global-toast" class="hidden fixed top-5 right-5 z-[100] px-6 py-3 rounded-lg shadow-lg text-white transform translate-x-[120%]">
        <p id="global-toast-message"></p>
    </div>

    <div class="w-full max-w-7xl mx-auto">
        <!-- Language Switcher -->
        <div class="absolute top-4 right-4 z-20">
            <div class="flex space-x-2 bg-gray-800 p-1 rounded-lg">
                <button id="lang-th" class="px-3 py-1 text-sm rounded-md transition">TH</button>
                <button id="lang-en" class="px-3 py-1 text-sm rounded-md transition">EN</button>
            </div>
        </div>

        <!-- View 1: Settings & Dashboard -->
        <div id="settings-view">
            <header class="text-center mb-8">
                <h1 class="text-4xl md:text-5xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500" data-lang-key="main_title">
                    AI UGC Product Ad Generator
                </h1>
                <p class="text-gray-400 mt-2" data-lang-key="main_subtitle">Create viral UGC ads, review, then render your video!</p>
            </header>
            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <aside id="main-controls" class="lg:col-span-2 bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 self-start">
                    <div class="flex flex-col space-y-6">
                        <!-- Main Settings -->
                        <div>
                            <label for="style-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_style">1. Select Style</label>
                            <select id="style-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"></select>
                        </div>
                        <div>
                            <label for="category-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_category">2. Select YouTube Category</label>
                            <select id="category-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                                <option value="22" selected>üë• People & Blogs</option>
                                <option value="1">üé¨ Film & Animation</option>
                                <option value="2">üöó Autos & Vehicles</option>
                                <option value="10">üéµ Music</option>
                                <option value="15">üêæ Pets & Animals</option>
                                <option value="17">‚öΩ Sports</option>
                                <option value="19">‚úàÔ∏è Travel & Events</option>
                                <option value="20">üéÆ Gaming</option>
                                <option value="23">üòÇ Comedy</option>
                                <option value="24">üé≠ Entertainment</option>
                                <option value="25">üì∞ News & Politics</option>
                                <option value="26">üé® Howto & Style</option>
                                <option value="27">üéì Education</option>
                                <option value="28">üî¨ Science & Technology</option>
                            </select>
                        </div>
                        <div>
                            <label for="language-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_language">3. Select Language</label>
                            <select id="language-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                                <option value="th" selected>‡πÑ‡∏ó‡∏¢ (Thai)</option>
                                <option value="en">English</option>
                            </select>
                        </div>
                        <div>
                            <label for="voice-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_voice">4. Select Voice</label>
                            <select id="voice-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"></select>
                        </div>
                        <div id="gemini-voice-config-container" class="hidden space-y-4">
                             <div>
                                <label for="gemini-model-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_native_model">Select Native Voice Model</label>
                                <select id="gemini-model-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                                    <option value="gemini-2.5-pro-preview-tts" data-lang-key="option_pro_model">Gemini 2.5 Pro (Highest Quality)</option>
                                    <option value="gemini-2.5-flash-preview-tts" data-lang-key="option_flash_model">Gemini 2.5 Flash (Fast)</option>
                                </select>
                            </div>
                             <div>
                                <label for="native-voice-selection" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_native_voice_1">Native Voice</label>
                                <select id="native-voice-selection" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"></select>
                            </div>
                        </div>
                        <div>
                            <label for="apiKey" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_api_key">5. Enter Google Cloud API Key (for Audio)</label>
                            <input type="password" id="apiKey" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" data-lang-key-placeholder="placeholder_api_key">
                        </div>
                        
                        <!-- Animation Settings -->
                        <div class="border-t border-gray-600 pt-6">
                            <div id="animation-header" class="flex justify-between items-center cursor-pointer">
                                <h3 class="text-xl font-bold text-white" data-lang-key="animation_settings_header">Animation Settings</h3>
                                <svg id="animation-chevron" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-400 transition-transform"><path d="m6 9 6 6 6-6"/></svg>
                            </div>
                            <div id="animation-container" class="collapsible-container mt-4 space-y-6">
                                <div>
                                    <label for="enable-zoom-checkbox" class="flex items-center space-x-3 cursor-pointer">
                                        <input type="checkbox" id="enable-zoom-checkbox" class="h-5 w-5 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-500">
                                        <span class="text-lg font-medium text-gray-300" data-lang-key="label_enable_zoom">Enable Zoom (Ken Burns)</span>
                                    </label>
                                </div>
                                <div>
                                    <label for="zoom-intensity-slider" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_zoom_intensity">Zoom Intensity</label>
                                    <input type="range" id="zoom-intensity-slider" min="1" max="15" step="1" value="5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                    <label for="enable-transition-checkbox" class="flex items-center space-x-3 cursor-pointer">
                                        <input type="checkbox" id="enable-transition-checkbox" class="h-5 w-5 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-500" checked>
                                        <span class="text-lg font-medium text-gray-300" data-lang-key="label_enable_transition">Enable Cross-Fade Transition</span>
                                    </label>
                                </div>
                                <div>
                                    <label for="transition-duration-slider" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_transition_duration">Transition Duration</label>
                                    <input type="range" id="transition-duration-slider" min="0.2" max="1.5" step="0.1" value="0.5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                        </div>

                        <!-- Subtitle Settings -->
                        <div class="border-t border-gray-600 pt-6">
                            <div id="subtitle-header" class="flex justify-between items-center cursor-pointer">
                                <h3 class="text-xl font-bold text-white" data-lang-key="subtitle_settings_header">Subtitle Settings</h3>
                                <svg id="subtitle-chevron" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-400 transition-transform"><path d="m6 9 6 6 6-6"/></svg>
                            </div>
                            <div id="subtitle-container" class="collapsible-container mt-4 space-y-6">
                                <div>
                                    <label for="show-subtitle-checkbox" class="flex items-center space-x-3 cursor-pointer">
                                        <input type="checkbox" id="show-subtitle-checkbox" class="h-5 w-5 rounded bg-gray-600 border-gray-500 text-blue-500 focus:ring-blue-500">
                                        <span class="text-lg font-medium text-gray-300" data-lang-key="label_show_subtitle">Show Subtitles</span>
                                    </label>
                                </div>
                                <div>
                                    <label for="font-style-select" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_font_style">Font Style</label>
                                    <select id="font-style-select" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                                        <option value="Sarabun">Sarabun (Default)</option>
                                        <option value="Kanit">Kanit</option>
                                        <option value="Mitr">Mitr</option>
                                        <option value="Prompt">Prompt</option>
                                    </select>
                                </div>
                                 <div>
                                    <label for="font-size-input" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_font_size">Font Size</label>
                                    <input type="number" id="font-size-input" value="60" min="20" max="150" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                                </div>
                                 <div>
                                    <label for="watermark-input" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_watermark">Watermark (Optional)</label>
                                    <input type="text" id="watermark-input" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" data-lang-key-placeholder="placeholder_watermark">
                                </div>
                                <div>
                                    <label for="outro-text-input" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_outro">Video Outro Text</label>
                                    <textarea id="outro-text-input" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" rows="3" data-lang-key-placeholder="placeholder_outro"></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- YouTube Upload Settings -->
                        <div class="border-t border-gray-600 pt-6">
                            <div id="youtube-header" class="flex justify-between items-center cursor-pointer">
                                <h3 class="text-xl font-bold text-white" data-lang-key="youtube_settings_header">YouTube Upload Settings</h3>
                                <svg id="youtube-chevron" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-gray-400 transition-transform"><path d="m6 9 6 6 6-6"/></svg>
                            </div>
                            <div id="youtube-container" class="collapsible-container mt-4 space-y-6">
                                <div>
                                    <label for="polveApiKey" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_polve_api_key">Polve API Key</label>
                                    <input type="password" id="polveApiKey" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" data-lang-key-placeholder="placeholder_polve_api_key">
                                    <p class="text-xs text-gray-400 mt-1">Get your API key at <a href="https://polve.me/auto-post" target="_blank" rel="noopener noreferrer" class="text-blue-400 hover:underline">polve.me/auto-post</a></p>
                                </div>
                            </div>
                        </div>

                        <!-- UGC Product Controls -->
                        <div id="ugc-product-controls" class="border-t border-gray-600 pt-6 space-y-4">
                            <div>
                                <label for="ugc-product-name" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_product_name">Product Name</label>
                                <input type="text" id="ugc-product-name" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" data-lang-key-placeholder="placeholder_product_name">
                            </div>
                            <div>
                                <label for="ugc-product-description" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_product_description">Product Description (Optional)</label>
                                <textarea id="ugc-product-description" class="w-full bg-gray-700 border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" rows="3" data-lang-key-placeholder="placeholder_product_description"></textarea>
                            </div>
                             <div>
                                <label for="ugc-product-image-label" class="block text-lg font-medium text-gray-300 mb-2" data-lang-key="label_product_image">Or Upload Product Image</label>
                                <input type="file" id="ugc-product-image" class="hidden" accept="image/*" multiple>
                                <label for="ugc-product-image" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 px-4 rounded-lg cursor-pointer flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
                                    <span data-lang-key="btn_select_image">Select Image</span>
                                </label>
                                <div id="ugc-image-preview" class="mt-4 flex flex-wrap gap-2 justify-center"></div>
                            </div>
                            <button id="generateUGCBtn" class="w-full bg-gradient-to-r from-rose-500 to-pink-600 hover:from-rose-600 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M12 6v12"/><path d="M17.6 14.5c1.8-1.4 3-3.5 3-5.5a5 5 0 0 0-10 0c0 2 1.2 4.1 3 5.5"/><path d="M12 22a2.5 2.5 0 0 0 2.5-2.5V18a2.5 2.5 0 0 0-5 0v1.5A2.5 2.5 0 0 0 12 22Z"/><path d="M15 2.5a2.5 2.5 0 0 0-5 0V6h5V2.5Z"/></svg>
                                <span data-lang-key="btn_generate_ugc">Generate UGC Ad</span>
                            </button>
                        </div>
                        
                        <!-- Batch Processing Section -->
                        <div id="batch-processing-controls" class="border-t border-gray-600 pt-6 space-y-4">
                            <h3 class="text-xl font-bold text-white" data-lang-key="batch_processing_header">Batch Processing from CSV</h3>
                            <p class="text-sm text-gray-400" data-lang-key="batch_processing_desc">Upload a CSV with columns: <strong>Product Title, Product Description, Main Image URL</strong>. The system will automatically generate a video for each row.</p>
                            <div>
                                <input type="file" id="batchCsvInput" class="hidden" accept=".csv">
                                <label for="batchCsvInput" class="w-full bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 px-4 rounded-lg cursor-pointer flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 17-4 4-4-4"/></svg>
                                    <span data-lang-key="btn_select_csv">Select CSV File</span>
                                </label>
                                <p id="csv-file-name" class="text-xs text-gray-400 mt-2 text-center"></p>
                            </div>
                             <div class="flex space-x-2">
                                <button id="batchProcessBtn" class="w-full bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out flex items-center justify-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
                                    <span data-lang-key="btn_start_batch">Start Batch Processing</span>
                                </button>
                                <button id="downloadAllMp4Btn" class="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                                    <span>Download All as MP4</span>
                                </button>
                            </div>
                        </div>

                    </div>
                </aside>
                <main class="lg:col-span-3">
                    <div id="video-cards-container" class="space-y-4">
                        </div>
                </main>
            </div>
        </div>

        <div id="preview-view" class="hidden">
             <div class="flex justify-between items-center mb-6">
                <button id="back-to-dashboard" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="m15 18-6-6 6-6"/></svg>
                    <span data-lang-key="btn_back_to_dashboard">Back to Dashboard</span>
                </button>
                 <h2 id="preview-title" class="text-xl font-bold text-center truncate"></h2>
                 <div class="w-24 h-24"></div> <!-- Placeholder for alignment -->
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-2 flex flex-col items-center justify-start">
                    <div class="w-full max-w-[300px] mx-auto mb-4">
                        <label for="playback-speed" class="block text-sm font-medium text-gray-400 mb-1" data-lang-key="label_playback_speed">Playback Speed:</label>
                        <select id="playback-speed" class="w-full bg-gray-700 border-gray-600 rounded-lg p-2 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                            <option value="1">1x</option>
                            <option value="1.25" selected>1.25x</option>
                            <option value="1.5">1.5x</option>
                            <option value="2">2x</option>
                        </select>
                    </div>
                    <div class="w-full max-w-[300px] bg-black rounded-2xl shadow-lg video-aspect overflow-hidden relative">
                        <canvas id="recording-canvas" width="1080" height="1920" class="w-full h-full absolute top-0 left-0 hidden"></canvas>
                        <audio id="audio-player" crossOrigin="anonymous" class="hidden" onerror="console.error('Audio Player Error:', this.error)"></audio>
                        <div id="video-player" class="w-full h-full relative">
                            <img id="video-image" src="" class="w-full h-full object-cover">
                        </div>
                        <div id="play-overlay" class="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 24 24" fill="white" class="transition-transform duration-300 ease-in-out"><path d="M8 5v14l11-7z"/></svg>
                        </div>
                        <div id="pause-button-container" class="absolute top-4 left-4 hidden">
                            <button id="pause-button" class="w-12 h-12 bg-black bg-opacity-50 rounded-full flex items-center justify-center text-white focus:outline-none"></button>
                        </div>
                    </div>
                     <div class="mt-4 w-full max-w-[300px] flex flex-col space-y-2">
                        <a id="downloadBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-center flex items-center justify-center cursor-pointer" title="‡πÑ‡∏ü‡∏•‡πå WebM ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                            <span data-lang-key="btn_download_video">Download Video</span>
                        </a>
                        <a id="downloadThumbnailBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-center flex items-center justify-center cursor-pointer" title="‡∏†‡∏≤‡∏û PNG ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
                            <span data-lang-key="btn_download_thumbnail">Download Thumbnail</span>
                        </a>
                        <button id="uploadToYouTubeBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-center flex items-center justify-center cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21.2 16.2a4.9 4.9 0 0 0-6.9-6.9l-1.4 1.4a4.9 4.9 0 0 0-6.9 6.9"/><path d="m12 19 6-6"/><path d="m3 11 6 6"/></svg>
                            <span data-lang-key="btn_upload_youtube">Upload to YouTube</span>
                        </button>
                    </div>
                </div>
                <div id="preview-playground-container" class="lg:col-span-3">
                    <h2 class="text-2xl font-bold text-center mb-4" data-lang-key="playground_title">Edit Images & Prompts</h2>
                    <div id="preview-playground-grid" class="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[80vh] overflow-y-auto pr-2">
                        </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Video Rendering Loader -->
    <div id="rendering-loader" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-75">
        <div class="flex flex-col items-center text-white">
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 mb-4"></div>
            <p id="rendering-loader-text" class="text-lg">Rendering video...</p>
        </div>
    </div>

    <!-- YouTube Upload Modal -->
    <div id="youtube-upload-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div id="upload-modal-overlay" class="absolute inset-0"></div>
        <div id="upload-modal-content" class="relative w-full max-w-2xl mx-auto rounded-xl shadow-2xl border border-gray-700 z-10">
            <div class="p-6 flex justify-between items-center border-b border-gray-700">
                <h3 class="text-xl font-semibold flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-6 w-6 text-red-500"><path d="M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17"></path><path d="m10 15 5-3-5-3z"></path></svg>
                    YouTube Uploader
                </h3>
                <button id="close-upload-modal-btn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="p-6 space-y-6">
                <!-- Channel -->
                <div class="space-y-2">
                    <label for="upload-channel-selector" class="upload-form-label">YouTube Channel *</label>
                    <select id="upload-channel-selector" class="upload-form-select w-full rounded-md px-3 py-2 border" disabled>
                        <option>Fetching channels...</option>
                    </select>
                </div>
                <!-- Video Preview -->
                <div class="space-y-2">
                    <label class="upload-form-label">Video to Upload</label>
                    <div id="upload-video-info" class="flex items-center gap-3 p-3 rounded-lg bg-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8 text-teal-400 flex-shrink-0"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"></path><rect x="2" y="6" width="14" height="12" rx="2"></rect></svg>
                        <p id="upload-video-filename" class="text-sm text-gray-300 truncate">video_file.webm</p>
                    </div>
                </div>
                <!-- Content Form -->
                <div id="upload-content-form" class="hidden space-y-4">
                    <!-- Title -->
                    <div class="space-y-2">
                        <label for="upload-video-title" class="upload-form-label">Title *</label>
                        <input type="text" id="upload-video-title" class="upload-form-input w-full rounded-md px-3 py-2 border" placeholder="Enter video title" maxlength="100">
                        <p id="upload-title-counter" class="text-xs text-right text-gray-400">0/100</p>
                    </div>
                    <!-- Description -->
                    <div class="space-y-2">
                        <label for="upload-video-description" class="upload-form-label">Description</label>
                        <textarea id="upload-video-description" class="upload-form-textarea w-full rounded-md px-3 py-2 border" placeholder="Enter video description" rows="3" maxlength="5000"></textarea>
                        <p id="upload-description-counter" class="text-xs text-right text-gray-400">0/5000</p>
                    </div>
                    <!-- Privacy & Category -->
                    <div class="grid grid-cols-2 gap-4">
                        <div class="space-y-2">
                            <label for="upload-privacy-selector" class="upload-form-label">Privacy</label>
                            <select id="upload-privacy-selector" class="upload-form-select w-full rounded-md px-3 py-2 border">
                                <option value="public" selected>üåç Public</option>
                                <option value="unlisted">üîó Unlisted</option>
                                <option value="private">üîí Private</option>
                            </select>
                        </div>
                        <div class="space-y-2">
                            <label for="upload-category-selector" class="upload-form-label">Category</label>
                            <select id="upload-category-selector" class="upload-form-select w-full rounded-md px-3 py-2 border"></select>
                        </div>
                    </div>
                </div>
                <!-- Upload Button -->
                <button id="upload-confirm-btn" class="w-full upload-primary-button h-11 rounded-md px-8 font-semibold inline-flex items-center justify-center gap-2" disabled>
                    <div id="upload-btn-loader" class="hidden loader w-5 h-5 border-2 border-gray-400 rounded-full"></div>
                    <svg id="upload-btn-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" x2="12" y1="3" y2="15"></line></svg>
                    <span id="upload-btn-text">Upload to YouTube</span>
                </button>
                 <div id="upload-status-message" class="mt-2 text-center text-sm"></div>
            </div>
        </div>
    </div>


    <template id="video-card-template">
        <div class="bg-gray-700 p-4 rounded-lg shadow-md">
            <div class="flex justify-between items-start">
                <div class="flex-grow min-w-0 mr-2">
                    <h3 class="font-bold text-lg truncate card-title" data-lang-key="card_title_default">Choose or create your script</h3>
                    <p class="text-sm text-gray-400 mt-1 card-status" data-lang-key="status_not_started">Not Started</p>
                </div>
                <div class="flex items-center flex-shrink-0">
                    <button class="delete-btn p-1 text-gray-400 hover:text-red-500 ml-1">
                         <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                    </button>
                </div>
            </div>
            <div class="script-details mt-4 text-sm space-y-4"></div>
            <div class="card-actions mt-4 flex space-x-2"></div>
        </div>
    </template>
    
    <template id="preview-scene-template">
        <div class="bg-gray-700 rounded-lg p-3">
            <h3 class="font-bold text-md mb-2 scene-title"></h3>
            <div class="relative">
                <img class="w-full rounded-md video-aspect object-cover scene-image">
                <div class="scene-loader absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
                    <div class="loader w-8 h-8 border-2 border-gray-500 rounded-full"></div>
                </div>
            </div>
            <textarea rows="3" class="w-full bg-gray-600 text-sm p-2 rounded-md mt-2 scene-prompt"></textarea>
            <div class="flex space-x-2 mt-2">
                <button class="regenerate-preview-btn flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg text-sm" data-lang-key="btn_regenerate">Regenerate</button>
                <label class="upload-btn flex-1 bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-3 rounded-lg text-sm text-center cursor-pointer" data-lang-key="btn_upload">Upload</label>
                <input type="file" accept="image/*" class="hidden scene-upload-input">
            </div>
        </div>
    </template>


    <script>
        // === DOM Elements ===
        const settingsView = document.getElementById('settings-view');
        const previewView = document.getElementById('preview-view');
        const backToDashboardBtn = document.getElementById('back-to-dashboard');

        const styleSelect = document.getElementById('style-selection');
        const categorySelect = document.getElementById('category-selection');
        const languageSelect = document.getElementById('language-selection');
        const voiceSelect = document.getElementById('voice-selection');
        const geminiVoiceConfigContainer = document.getElementById('gemini-voice-config-container');
        const geminiModelSelection = document.getElementById('gemini-model-selection');
        const nativeVoiceSelection = document.getElementById('native-voice-selection');
        const apiKeyInput = document.getElementById('apiKey');
        const polveApiKeyInput = document.getElementById('polveApiKey');
        
        const ugcProductControls = document.getElementById('ugc-product-controls');
        const ugcProductNameInput = document.getElementById('ugc-product-name');
        const ugcProductDescriptionInput = document.getElementById('ugc-product-description');
        const ugcProductImageInput = document.getElementById('ugc-product-image');
        const ugcImagePreview = document.getElementById('ugc-image-preview');
        const generateUGCBtn = document.getElementById('generateUGCBtn');
        
        // Batch processing elements
        const batchCsvInput = document.getElementById('batchCsvInput');
        const batchProcessBtn = document.getElementById('batchProcessBtn');
        const csvFileNameEl = document.getElementById('csv-file-name');
        const downloadAllMp4Btn = document.getElementById('downloadAllMp4Btn');


        // Subtitle settings
        const subtitleHeader = document.getElementById('subtitle-header');
        const subtitleContainer = document.getElementById('subtitle-container');
        const subtitleChevron = document.getElementById('subtitle-chevron');
        const showSubtitleCheckbox = document.getElementById('show-subtitle-checkbox');
        const fontStyleSelect = document.getElementById('font-style-select');
        const fontSizeInput = document.getElementById('font-size-input');
        const watermarkInput = document.getElementById('watermark-input');
        const outroTextInput = document.getElementById('outro-text-input');
        const youtubeHeader = document.getElementById('youtube-header');
        const youtubeContainer = document.getElementById('youtube-container');
        const youtubeChevron = document.getElementById('youtube-chevron');
        
        // Animation Settings
        const animationHeader = document.getElementById('animation-header');
        const animationContainer = document.getElementById('animation-container');
        const animationChevron = document.getElementById('animation-chevron');
        const enableZoomCheckbox = document.getElementById('enable-zoom-checkbox');
        const zoomIntensitySlider = document.getElementById('zoom-intensity-slider');
        const enableTransitionCheckbox = document.getElementById('enable-transition-checkbox');
        const transitionDurationSlider = document.getElementById('transition-duration-slider');

        const videoCardsContainer = document.getElementById('video-cards-container');
        const videoCardTemplate = document.getElementById('video-card-template');
        
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadThumbnailBtn = document.getElementById('downloadThumbnailBtn');
        const uploadToYouTubeBtn = document.getElementById('uploadToYouTubeBtn');
        
        const videoPlayer = document.getElementById('video-player');
        const videoImage = document.getElementById('video-image');
        const playOverlay = document.getElementById('play-overlay');
        const pauseButtonContainer = document.getElementById('pause-button-container');
        const pauseButton = document.getElementById('pause-button');
        
        const canvas = document.getElementById('recording-canvas');
        const ctx = canvas.getContext('2d');
        const audioPlayer = document.getElementById('audio-player');
        
        const playbackSpeedSelect = document.getElementById('playback-speed');
        const previewTitle = document.getElementById('preview-title');
        const previewPlaygroundGrid = document.getElementById('preview-playground-grid');
        const previewSceneTemplate = document.getElementById('preview-scene-template');
        
        const langThBtn = document.getElementById('lang-th');
        const langEnBtn = document.getElementById('lang-en');

        // === Rendering & Upload Modal DOM Elements ===
        const renderingLoader = document.getElementById('rendering-loader');
        const renderingLoaderText = document.getElementById('rendering-loader-text');
        const uploadModal = document.getElementById('youtube-upload-modal');
        const uploadModalOverlay = document.getElementById('upload-modal-overlay');
        const closeUploadModalBtn = document.getElementById('close-upload-modal-btn');
        const uploadChannelSelector = document.getElementById('upload-channel-selector');
        const uploadVideoFilename = document.getElementById('upload-video-filename');
        const uploadContentForm = document.getElementById('upload-content-form');
        const uploadVideoTitle = document.getElementById('upload-video-title');
        const uploadTitleCounter = document.getElementById('upload-title-counter');
        const uploadVideoDescription = document.getElementById('upload-video-description');
        const uploadDescriptionCounter = document.getElementById('upload-description-counter');
        const uploadPrivacySelector = document.getElementById('upload-privacy-selector');
        const uploadCategorySelector = document.getElementById('upload-category-selector');
        const uploadConfirmBtn = document.getElementById('upload-confirm-btn');
        const uploadStatusMessage = document.getElementById('upload-status-message');
        const uploadBtnLoader = document.getElementById('upload-btn-loader');
        const uploadBtnIcon = document.getElementById('upload-btn-icon');
        const uploadBtnText = document.getElementById('upload-btn-text');


        let videoJobs = [];
        let currentJob = null;
        let activeSceneIndex = -1;
        let isPlaying = false;
        let isPaused = false;
        let mediaRecorder;
        let recordedChunks = [];
        let animationFrameId;
        
        let audioContext = null;
        let voiceSourceNode;
        let voiceGainNode;
        let mediaStreamDestination = null;
        let audioGraphInitialized = false;
        
        let generatedVideoFile = null;
        let ugcImageBase64s = [];
        
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>`;

        const langCodeMap = { 'th': 'th-TH', 'en': 'en-US' };
        const langNameMap = { 'th': 'Thai', 'en': 'English' };
        
        const allNativeVoices = ['Zephyr','Puck','Charon','Kore','Fenrir','Leda','Orus','Aoede','Callirrhoe','Autonoe','Enceladus','Iapetus','Umbriel','Algieba','Despina','Erinome','Algenib','Rasalgethi','Laomedeia','Achernar','Alnilam','Schedar','Gacrux','Pulcherrima','Achird','Zubenelgenubi','Vindemiatrix','Sadachbia','Sadaltager','Sulafat'];
        const UPLOAD_API_BASE_URL = "https://ygscgkfqeiuclsolvscm.supabase.co/functions/v1";
        
        const styleOptions = {
            ugc_product: [
                 { name: 'Modern & Clean', value: 'cinematic' },
                 { name: 'User Review Style', value: 'photorealistic' },
                 { name: 'Fun & Quirky', value: 'cute2d' }
            ]
        };

        const stylePromptMap = {
            cinematic: "cinematic, photorealistic, high detail, epic lighting, 8k",
            photorealistic: "photorealistic, ultra realistic, 8k, detailed, sharp focus",
            cute2d: "cute 2d animation style, storybook illustration, friendly characters, vibrant colors, soft lighting",
        };

        const CHARACTER_DESCRIPTION = "A beautiful 25-year-old Thai woman with fair skin, long straight dark brown hair, and friendly brown eyes. She is dressed in stylish, modern, casual clothing. Photorealistic, consistent character.";


        // === I18n (Internationalization) ===
        const translations = {
            en: {
                main_title: "AI UGC Product Ad Generator",
                main_subtitle: "Create viral UGC ads, review, then render your video!",
                label_style: "1. Select Style",
                label_category: "2. Select YouTube Category",
                label_language: "3. Select Language",
                label_voice: "4. Select Voice",
                label_native_model: "Select Native Voice Model",
                option_pro_model: "Gemini 2.5 Pro (Highest Quality)",
                option_flash_model: "Gemini 2.5 Flash (Fast)",
                label_native_voice_1: "Native Voice",
                label_api_key: "5. Enter Google Cloud API Key (for Audio)",
                placeholder_api_key: "API Key for audio services only",
                animation_settings_header: "Animation Settings",
                label_enable_zoom: "Enable Zoom (Ken Burns)",
                label_zoom_intensity: "Zoom Intensity",
                label_enable_transition: "Enable Cross-Fade Transition",
                label_transition_duration: "Transition Duration",
                subtitle_settings_header: "Subtitle Settings",
                label_show_subtitle: "Show Subtitles",
                label_font_style: "Font Style",
                label_font_size: "Font Size",
                label_watermark: "Watermark (Optional)",
                placeholder_watermark: "e.g., @yourchannel",
                label_outro: "Video Outro Text",
                placeholder_outro: "e.g., Don't forget to like and subscribe...",
                youtube_settings_header: "YouTube Upload Settings",
                label_polve_api_key: "Polve API Key",
                placeholder_polve_api_key: "Enter your Polve API key for uploads",
                btn_back_to_dashboard: "Back to Dashboard",
                label_go_viral: "Go Viral",
                label_playback_speed: "Playback Speed:",
                btn_download_video: "Download Video",
                btn_download_thumbnail: "Download Thumbnail",
                btn_upload_youtube: "Upload to YouTube",
                playground_title: "Edit Images & Prompts",
                status_not_started: "Not Started",
                card_title_default: "Choose or create your script",
                btn_retry: "Try Again",
                btn_refine_prompt: "Refine Prompt",
                label_thumbnail_prompt: "Thumbnail (Prompt)",
                label_scene: "Scene",
                btn_save_script: "Save Script",
                btn_generate_video: "Next",
                status_video_ready: "‚úÖ Video Ready",
                btn_preview_video: "Preview Video",
                label_thumbnail: "Thumbnail",
                btn_regenerate: "Regenerate",
                btn_upload: "Upload",
                status_generating_script: "Generating script...",
                error_script_format: "Could not generate script in the correct format.",
                status_ready_to_generate: "Ready to generate scenes",
                error_generic: "Error",
                status_generating_image: "Generating image",
                error_image_generation: "Failed to generate image for",
                status_generating_audio: "Generating audio",
                error_audio_generation: "Failed to generate audio for scene",
                error_image_regeneration: "Failed to regenerate image",
                error_audio_init: "Could not initialize audio. You may need to refresh the page.",
                alert_api_key: "Please enter your Google Cloud API Key for audio services.",
                alert_polve_api_key: "Please enter your Polve API Key in the settings.",
                alert_no_video_data: "No video data to upload. Please generate and preview a video first.",
                status_uploading: "Uploading to YouTube...",
                status_upload_success: "‚úÖ Video uploaded successfully! URL:",
                status_upload_failed: "‚ùå Upload failed:",
                status_media_failed: "‚ùå Media generation failed. Please check scenes and retry.",
                btn_retry_media: "Retry Media Generation",
                label_product_name: "Product Name",
                placeholder_product_name: "e.g., 'Super Glow Serum'",
                label_product_description: "Product Description (Optional)",
                placeholder_product_description: "Enter key features, benefits, etc.",
                label_product_image: "Or Upload Product Image",
                btn_select_image: "Select Image",
                btn_generate_ugc: "Generate UGC Ad",
                alert_ugc_input: "Please provide a Product Name or upload an image.",
                alert_select_script: "Please select a script variation first.",
                batch_processing_header: "Batch Processing from CSV",
                batch_processing_desc: "Upload a CSV with columns: <strong>Product Title, Product Description, Main Image URL</strong>. The system will automatically generate a video for each row.",
                btn_select_csv: "Select CSV File",
                btn_start_batch: "Start Batch Processing",
                alert_select_csv: "Please select a CSV file first.",
                processing_batch: "Processing batch... Please wait.",
                batch_complete: "Batch processing complete.",
                error_processing_row: "Error processing row"
            },
            th: {
                main_title: "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ UGC ‡∏î‡πâ‡∏ß‡∏¢ AI",
                main_subtitle: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤ UGC ‡πÑ‡∏ß‡∏£‡∏±‡∏• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠!",
                label_style: "1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡πÑ‡∏ï‡∏•‡πå",
                label_category: "2. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà YouTube",
                label_language: "3. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏†‡∏≤‡∏©‡∏≤",
                label_voice: "4. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏≤‡∏Å‡∏¢‡πå",
                label_native_model: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏á Native",
                option_pro_model: "Gemini 2.5 Pro (‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î)",
                option_flash_model: "Gemini 2.5 Flash (‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß)",
                label_native_voice_1: "‡πÄ‡∏™‡∏µ‡∏¢‡∏á Native",
                label_api_key: "5. ‡πÉ‡∏™‡πà Google Cloud API Key (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á)",
                placeholder_api_key: "API Key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô",
                animation_settings_header: "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏ä‡∏±‡∏ô",
                label_enable_zoom: "‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏π‡∏° (Ken Burns)",
                label_zoom_intensity: "‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡∏π‡∏°",
                label_enable_transition: "‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏â‡∏≤‡∏Å (Cross-Fade)",
                label_transition_duration: "‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏â‡∏≤‡∏Å",
                subtitle_settings_header: "‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≥‡∏ö‡∏£‡∏£‡∏¢‡∏≤‡∏¢",
                label_show_subtitle: "‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏ö‡∏£‡∏£‡∏¢‡∏≤‡∏¢ (Subtitle)",
                label_font_style: "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£",
                label_font_size: "‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£",
                label_watermark: "‡∏•‡∏≤‡∏¢‡∏ô‡πâ‡∏≥ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å)",
                placeholder_watermark: "‡πÄ‡∏ä‡πà‡∏ô @‡∏ä‡πà‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì",
                label_outro: "‡∏Ñ‡∏≥‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠",
                placeholder_outro: "‡πÄ‡∏ä‡πà‡∏ô ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏∑‡∏°‡∏Å‡∏î‡∏ñ‡∏π‡∏Å‡πÉ‡∏à‡πÅ‡∏•‡∏∞‡∏Å‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏≠‡∏ö‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ó‡∏ô‡∏ï‡πå‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ",
                youtube_settings_header: "‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î YouTube",
                label_polve_api_key: "Polve API Key",
                placeholder_polve_api_key: "‡πÉ‡∏™‡πà Polve API key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î",
                btn_back_to_dashboard: "‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å",
                label_go_viral: "Go Viral",
                label_playback_speed: "‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô:",
                btn_download_video: "‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠",
                btn_download_thumbnail: "‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Thumbnail",
                btn_upload_youtube: "‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏õ YouTube",
                playground_title: "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞ Prompt",
                status_not_started: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°",
                card_title_default: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì",
                btn_retry: "‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á",
                btn_refine_prompt: "‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Prompt",
                label_thumbnail_prompt: "‡∏†‡∏≤‡∏û‡∏õ‡∏Å (Prompt)",
                label_scene: "‡∏â‡∏≤‡∏Å‡∏ó‡∏µ‡πà",
                btn_save_script: "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå",
                btn_generate_video: "‡∏ñ‡∏±‡∏î‡πÑ‡∏õ",
                status_video_ready: "‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
                btn_preview_video: "‡∏î‡∏π‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠",
                label_thumbnail: "‡∏†‡∏≤‡∏û‡∏õ‡∏Å",
                btn_regenerate: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà",
                btn_upload: "‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î",
                status_generating_script: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå...",
                error_script_format: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
                status_ready_to_generate: "‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ã‡∏µ‡∏ô",
                error_generic: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
                status_generating_image: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà",
                error_image_generation: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö",
                status_generating_audio: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏≤‡∏Å‡∏¢‡πå",
                error_audio_generation: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏≤‡∏Å‡∏¢‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏â‡∏≤‡∏Å‡∏ó‡∏µ‡πà",
                error_image_regeneration: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà",
                error_audio_init: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÑ‡∏î‡πâ ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö",
                alert_api_key: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Google Cloud API Key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏á",
                alert_polve_api_key: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Polve API Key ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤",
                alert_no_video_data: "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡πà‡∏≠‡∏ô",
                status_uploading: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏õ YouTube...",
                status_upload_success: "‚úÖ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! URL:",
                status_upload_failed: "‚ùå ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:",
                status_media_failed: "‚ùå ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ã‡∏µ‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
                btn_retry_media: "‡∏•‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà",
                rendering_for_download: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏ô‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...",
                rendering_for_upload: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î...",
                label_product_name: "‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤",
                placeholder_product_name: "‡πÄ‡∏ä‡πà‡∏ô '‡πÄ‡∏ã‡∏£‡∏±‡πà‡∏°‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏™ Super Glow'",
                label_product_description: "‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å)",
                placeholder_product_description: "‡πÉ‡∏™‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥, ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡πà‡∏ô, ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏Ç‡∏≠‡∏á‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤...",
                label_product_image: "‡∏´‡∏£‡∏∑‡∏≠ ‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤",
                btn_select_image: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û",
                btn_generate_ugc: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤",
                alert_ugc_input: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û",
                alert_select_script: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏Å‡πà‡∏≠‡∏ô",
                batch_processing_header: "‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏≤‡∏Å CSV",
                batch_processing_desc: "‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå CSV ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: <strong>Product Title, Product Description, Main Image URL</strong> ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
                btn_select_csv: "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV",
                btn_start_batch: "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•",
                alert_select_csv: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV ‡∏Å‡πà‡∏≠‡∏ô",
                processing_batch: "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•... ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà",
                batch_complete: "‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô",
                error_processing_row: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà"
            }
        };
        let currentLanguage = localStorage.getItem('appLanguage') || 'th';

        // --- NEW: Global Message Function ---
        const globalToast = document.getElementById('global-toast');
        const globalToastMessage = document.getElementById('global-toast-message');
        let toastTimeout;

        function showGlobalMessage(message, type = 'info', duration = 5000) {
            clearTimeout(toastTimeout);

            globalToastMessage.textContent = message;
            
            globalToast.classList.remove('bg-red-600', 'bg-green-600', 'bg-blue-600', 'hidden', 'translate-x-0');
            globalToast.classList.add('translate-x-[120%]'); // Reset position

            if (type === 'error') {
                globalToast.classList.add('bg-red-600');
            } else if (type === 'success') {
                globalToast.classList.add('bg-green-600');
            } else {
                globalToast.classList.add('bg-blue-600');
            }

            globalToast.classList.remove('hidden');
            
            // Animate in
            setTimeout(() => {
                globalToast.classList.remove('translate-x-[120%]');
                globalToast.classList.add('translate-x-0');
            }, 10);

            // Set timeout to hide
            toastTimeout = setTimeout(() => {
                globalToast.classList.remove('translate-x-0');
                globalToast.classList.add('translate-x-[120%]');
            }, duration);
        }
        
        // --- Functions ---
        
        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('appLanguage', lang);
            document.documentElement.lang = lang;
            
            if (lang === 'en') {
                document.body.style.fontFamily = "'Inter', sans-serif";
                langEnBtn.classList.add('bg-blue-600', 'text-white');
                langThBtn.classList.remove('bg-blue-600', 'text-white');
            } else {
                document.body.style.fontFamily = "'Sarabun', sans-serif";
                langThBtn.classList.add('bg-blue-600', 'text-white');
                langEnBtn.classList.remove('bg-blue-600', 'text-white');
            }

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });
            
            document.querySelectorAll('[data-lang-key-placeholder]').forEach(el => {
                const key = el.getAttribute('data-lang-key-placeholder');
                if (translations[lang][key]) {
                    el.placeholder = translations[lang][key];
                }
            });

            updateVoiceOptions();
            updateDefaultOutro();
        }
        
        function populateNativeVoiceDropdowns() {
            [nativeVoiceSelection].forEach(select => {
                select.innerHTML = '';
                allNativeVoices.forEach(voiceName => {
                    const option = document.createElement('option');
                    option.value = voiceName;
                    option.textContent = voiceName;
                    select.appendChild(option);
                });
            });
            nativeVoiceSelection.value = 'Zephyr';
        }

        function updateVoiceOptions() {
            const lang = currentLanguage;
            const voiceMap = {
                'th': [
                    { name: '‡πÄ‡∏™‡∏µ‡∏¢‡∏á Native', value: 'gemini-native-th' },
                    { name: '‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ú‡∏π‡πâ‡∏´‡∏ç‡∏¥‡∏á (‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á)', value: 'th-TH-Chirp3-HD-Aoede' }, 
                    { name: '‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ú‡∏π‡πâ‡∏ä‡∏≤‡∏¢ (‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á)', value: 'th-TH-Chirp3-HD-Charon' }
                ],
                'en': [
                    { name: 'Native Voice', value: 'gemini-native-en' },
                    { name: 'Female (High Quality)', value: 'en-US-News-N' }, 
                    { name: 'Male (High Quality)', value: 'en-US-News-M' }
                ]
            };
            const voices = voiceMap[lang];
            voiceSelect.innerHTML = '';
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.value;
                option.textContent = voice.name;
                voiceSelect.appendChild(option);
            });
            toggleGeminiConfig();
        }

        function toggleGeminiConfig() {
            if (voiceSelect.value.startsWith('gemini-native')) {
                geminiVoiceConfigContainer.classList.remove('hidden');
            } else {
                geminiVoiceConfigContainer.classList.add('hidden');
            }
        }
        
        function updateDefaultOutro() {
             outroTextInput.value = "";
        }
        
        function populateStyleOptions() {
            const styles = styleOptions['ugc_product'];
            styleSelect.innerHTML = '';
            styles.forEach(style => {
                const option = document.createElement('option');
                option.value = style.value;
                option.textContent = style.name;
                styleSelect.appendChild(option);
            });
        }

        async function generateUGCScript(productName, productDescription, imageBase64Array, language) {
            const languageName = langNameMap[language];
            
            const promptText = `You are an expert UGC (User-Generated Content) scriptwriter for social media ads. A user wants to create an ad for their product.

Product Name: ${productName}
${productDescription ? `Product Description: ${productDescription}` : ''}
Language: ${languageName}

Your task is to generate 3 distinct ad scripts. Each script must follow this structure:
1.  **Hook (1-3 seconds):** Start with a strong, attention-grabbing question or statement that creates curiosity without mentioning the product. (e.g., "‡πÄ‡∏à‡∏≠‡πÅ‡∏•‡πâ‡∏ß! ‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ï‡∏¥‡∏î‡∏ö‡πâ‡∏≤‡∏ô", "‡πÄ‡∏Ñ‡∏¢‡πÄ‡∏à‡∏≠‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏ô‡∏µ‡πâ‡πÑ‡∏´‡∏°?")
2.  **Attention (5-10 seconds):** Build on the hook. Describe a problem, a need, or a desirable situation. Show the "before" state or the struggle. Keep the viewer engaged.
3.  **Sell (5-10 seconds):** Introduce the product as the solution. Clearly state the **Product Name** here. Show the "after" state or the benefits. End with a clear call to action.

**Crucial Rule:** The product name "${productName}" must ONLY be mentioned in the "Sell" part of the script, near the end.

Return a single, valid JSON object with the key "script_variations". This key should hold an array of the 3 generated script objects. Each object must have:
- "title": A short, catchy title for the script variation (e.g., "Problem/Solution Hook").
- "script_text": The full script text you wrote.

You must reply with only the JSON object. Do not include any other text or markdown.`;

            let promptParts = [];
            if (imageBase64Array && imageBase64Array.length > 0) {
                promptParts.push({ text: `Analyze the product(s) in these images. Identify them, their key features, and target audience.` });
                imageBase64Array.forEach(base64 => {
                    promptParts.push({
                        inlineData: { mimeType: 'image/jpeg', data: base64 }
                    });
                });
                promptParts.push({ text: promptText });
            } else {
                promptParts.push({ text: promptText });
            }
            
            try {
                const payload = { contents: [{ role: "user", parts: promptParts }] };
                const geminiApiKey = ""; // Canvas provided
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API error! status: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) {
                    const rawText = result.candidates[0].content.parts[0].text.replace(/```json|```/g, '').trim();
                    return JSON.parse(rawText);
                }
                throw new Error("Invalid response structure from Gemini API for UGC script.");
            } catch (error) {
                console.error("Error generating UGC script:", error);
                throw error;
            }
        }
        
        async function generateScenesFromScript(scriptText, scriptTitle, style, imageUrl) {
             const languageName = langNameMap[languageSelect.value];
             const visualStyleInstruction = stylePromptMap[style] || "cinematic, photorealistic";

             const prompt = `You are a video director. Take the following UGC ad script and break it down into scenes for a 15-30 second YouTube Short. The script has a specific style/angle which you must reflect in the visual descriptions.

**Script Angle/Title:** "${scriptTitle}"
**Script Text:** ${JSON.stringify(scriptText)}
**Visual Style:** "${visualStyleInstruction}"

Your task is to create a JSON object with a single key: "scenes".
"scenes": An array of 4-6 JSON objects for the video scenes. Each scene object must have:
    - "text": The spoken script for that specific scene, written in ${languageName}.
    - "visual": A corresponding visual description for the scene, written in English. The visuals must match the script's angle (e.g., for a problem/solution hook, show the problem first, then the solution). **If a scene requires a person, simply describe their action (e.g., 'A woman smiles as she sips the drink'). Do not describe her appearance; the system will maintain a consistent character.**

You must reply with only a single, valid JSON object that contains the "scenes" array. Do not include any other text or markdown.`;

            try {
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                const geminiApiKey = ""; // Canvas provided
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Scene generation API error! status: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) {
                    const rawText = result.candidates[0].content.parts[0].text.replace(/```json|```/g, '').trim();
                    const sanitizedText = rawText.replace(/[\u0000-\u001F\u007F-\u009F]/g, "");
                    const sceneData = JSON.parse(sanitizedText);
                    
                    // Modify the last scene to use the product image
                    if (sceneData.scenes && sceneData.scenes.length > 0 && imageUrl) {
                        const lastScene = sceneData.scenes[sceneData.scenes.length - 1];
                        lastScene.visual = imageUrl; // Replace prompt with the actual image URL
                        lastScene.isProductImage = true; // Add a flag
                        lastScene.isUploaded = true; // Treat it like an uploaded image for rendering
                    }

                    return sceneData;
                }
                throw new Error("Invalid response structure from scene generation API.");
            } catch (error) {
                console.error("Error generating scenes from script:", error);
                throw error;
            }
        }

        async function refinePrompt(originalPrompt) {
            const metaPrompt = `You are an expert prompt engineer for a text-to-image AI. Your task is to rewrite a given prompt to make it safer and more effective, increasing the likelihood of successful image generation.

**Key Principles:**
1.  **Describe, Don't Command:** Focus on describing the visual scene, atmosphere, lighting, and composition.
2.  **De-escalate Sensitive Words:** Identify and replace words that might trigger safety filters (e.g., words related to violence, conflict, harm, or adult themes). Rephrase them into neutral, descriptive alternatives. For example, instead of "a man fighting", use "two figures in a dynamic, tense pose". Instead of "blood", use "red liquid stains".
3.  **Abstract to Visual:** Convert abstract concepts into concrete visual descriptions. Instead of "a symbol of hope", describe "a single plant growing through a crack in concrete, bathed in morning light".
4.  **Generalize Identities:** If the prompt mentions a specific, real person, try to describe their key characteristics instead of using their name, unless the name is essential for a well-known fictional or historical archetype (e.g., "a brilliant Indian mathematician with an intense, focused expression, reminiscent of Ramanujan").
5.  **Maintain Core Idea:** The new prompt must retain the original's core subject and intent.

**Your Task:**
Rewrite the following prompt based on these principles. Respond with **only** the new, refined prompt text.

Original Prompt: "${originalPrompt}"

Refined Prompt:`;
            try {
                const chatHistory = [{ role: "user", parts: [{ text: metaPrompt }] }];
                const payload = { contents: chatHistory };
                const geminiApiKey = ""; // Canvas provided
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API error! status: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) {
                    return result.candidates[0].content.parts[0].text.trim();
                }
                return originalPrompt;
            } catch (error) {
                console.error("Error refining prompt:", error);
                return originalPrompt;
            }
        }

        async function generateImage(prompt, style) {
            const stylePrefix = stylePromptMap[style] || stylePromptMap['cinematic'];
            
            // Check for keywords indicating a person and prepend the character description if found.
            const personKeywords = ['woman', 'person', 'expert', 'user', 'girl', 'lady', 'she', 'her'];
            const containsPerson = personKeywords.some(keyword => new RegExp(`\\b${keyword}\\b`, 'i').test(prompt));
            
            let fullPrompt = containsPerson ? `${CHARACTER_DESCRIPTION}, ${prompt}` : prompt;

            const positivePrompt = `${stylePrefix}, ${fullPrompt}, 9:16 aspect ratio, high detail, sharp focus, hyperdetailed`;
            const negativePrompt = "text, words, letters, font, logo, typography, signature, watermark, characters, numbers, writing, captions, titles, heading, label, sign, banner, ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£, ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°, ‡∏õ‡πâ‡∏≤‡∏¢, blurry, low quality, pixelated, noisy, deformed, malformed, ugly, bad anatomy";
            try {
                const payload_img = { instances: [{ prompt: positivePrompt, negativePrompt: negativePrompt }], parameters: { "sampleCount": 1 } };
                const geminiApiKey = ""; // Canvas provided
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${geminiApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload_img) });
                if (!response.ok) {
                     const errorText = await response.text();
                     console.error("Imagen API Error Response:", errorText);
                     throw new Error(`API error! status: ${response.status}`);
                }
                const result = await response.json();
                if (result.predictions && result.predictions[0].bytesBase64Encoded) {
                    return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                }
                throw new Error("No image data in Imagen API response.");
            } catch (error) {
                console.error('Imagen API error:', error);
                throw error;
            }
        }

        function base64ToBytes(base64) {
            const binString = atob(base64);
            const len = binString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binString.charCodeAt(i);
            }
            return bytes;
        }

        function createWavDataUrl(base64Pcm, sampleRate) {
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            const pcmBytes = base64ToBytes(base64Pcm);
            const n = pcmBytes.length;
            const buffer = new ArrayBuffer(44 + n);
            const view = new DataView(buffer);

            const channels = 1; // Mono
            const bitsPerSample = 16;
            const blockAlign = channels * (bitsPerSample / 8);
            const byteRate = sampleRate * blockAlign;
            const dataSize = n;
            const fileSize = 36 + dataSize;

            writeString(view, 0, 'RIFF');
            view.setUint32(4, fileSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, channels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            new Uint8Array(view.buffer, 44).set(pcmBytes);

            const audioBlob = new Blob([view.buffer], { type: 'audio/wav' });

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                reader.readAsDataURL(audioBlob);
            });
        }

        async function getGeminiTTSAudio(text, userApiKey, voiceName, modelName) {
            const model = modelName;
            const api = 'streamGenerateContent';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:${api}?key=${userApiKey}`;

            const payload = {
                contents: [{ role: 'user', parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ['audio'],
                    speech_config: {
                        voice_config: {
                            prebuilt_voice_config: { voice_name: voiceName }
                        }
                    }
                }
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.json();
                    console.error("Gemini TTS API HTTP Error:", errorDetails);
                    throw new Error(errorDetails.error?.message || `HTTP error! status: ${response.status}`);
                }
                
                const responseText = await response.text();
                let chunks;
                try {
                    chunks = JSON.parse(responseText);
                } catch (e) {
                    console.error("Failed to parse Gemini TTS API response:", responseText);
                    throw new Error("Invalid JSON response from TTS API.");
                }
                
                if (!Array.isArray(chunks)) {
                    console.error("Unexpected TTS response format. Expected an array of chunks, got:", chunks);
                    throw new Error("Unexpected TTS response format.");
                }

                let fullBase64Data = '';
                let mimeType = '';

                for (const chunk of chunks) {
                    if (!chunk.candidates || chunk.candidates.length === 0) {
                        console.warn("TTS chunk received without candidates:", chunk);
                        continue;
                    }

                    const part = chunk.candidates[0]?.content?.parts?.[0];
                    if (part?.inlineData) {
                        fullBase64Data += part.inlineData.data;
                        if (part.inlineData.mimeType) {
                            mimeType = part.inlineData.mimeType;
                        }
                    } else {
                        console.warn("TTS chunk received with a non-audio part:", part);
                    }
                }
                
                if (fullBase64Data) {
                    if (mimeType.includes('audio/L16')) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                        return createWavDataUrl(fullBase64Data, sampleRate);
                    }
                    return `data:${mimeType};base64,${fullBase64Data}`;
                }

                console.error("No audio data found in any chunk of the Gemini TTS response. Full response:", chunks);
                throw new Error('No audio data in Gemini TTS response.');

            } catch (error) {
                console.error("Error calling or parsing Gemini TTS API:", error);
                throw error;
            }
        }
        
        async function getGoogleTTSAudioWithTimestamps(texts, voiceName, languageCode, userApiKey) {
            const ssmlScript = texts.map((text, index) => `<mark name="${index}"/>${text}`).join(' ');
            const ttsApiUrl = `https://texttospeech.googleapis.com/v1beta1/text:synthesize`;
            
            const payload = {
                input: { ssml: `<speak>${ssmlScript}</speak>` },
                voice: { languageCode: languageCode, name: voiceName },
                audioConfig: { 
                    audioEncoding: 'MP3'
                },
                enableTimePointing: ['SSML_MARK'] 
            };

            const response = await fetch(ttsApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': userApiKey
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorDetails = await response.json();
                console.error("Google TTS API Error:", errorDetails);
                throw new Error(errorDetails.error.message || 'Unknown TTS error');
            }
            const result = await response.json();
            if (!result.audioContent || !result.timepoints) {
                throw new Error('Missing audio or timepoints in TTS response');
            }

            const audioSrc = `data:audio/mp3;base64,${result.audioContent}`;
            const timepoints = result.timepoints.map(tp => ({...tp, timeSeconds: parseFloat(tp.timeSeconds)}));
            
            return { audioSrc, timepoints };
        }

        
        function updateCardUI(jobId, { title, status, scriptData, error = false, ready = false, media_failed = false, scenesToRender = null }) {
            const card = document.querySelector(`[data-job-id="${jobId}"]`);
            if (!card) return;

            const job = videoJobs.find(j => j.id === jobId);
            if (!job) return; 

            const titleEl = card.querySelector('.card-title');
            const statusEl = card.querySelector('.card-status');
            const scriptDetailsEl = card.querySelector('.script-details');
            const actionsEl = card.querySelector('.card-actions');
            
            if (title) titleEl.textContent = title;
            
            if (status) {
                statusEl.textContent = status;
                statusEl.classList.remove('text-green-400', 'text-red-400', 'text-gray-400');
                if (status.includes('‚úÖ') || status.includes('Downloaded')) {
                    statusEl.classList.add('text-green-400');
                } else if (status.includes('‚ùå') || status.includes('Failed')) {
                    statusEl.classList.add('text-red-400');
                } else {
                    statusEl.classList.add('text-gray-400');
                }
            }

            if (error) {
                statusEl.classList.remove('text-gray-400', 'text-green-400');
                statusEl.classList.add('text-red-400');
                scriptDetailsEl.innerHTML = '';
                actionsEl.innerHTML = `<button class="regenerate-script-btn w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">${translations[currentLanguage].btn_retry}</button>`;
                card.querySelector('.regenerate-script-btn').onclick = (e) => {
                    e.stopPropagation();
                    handleRegenerate(jobId, e.target);
                };
                return;
            }

            if (scriptData && scriptData.script_variations) {
                let scriptHtml = '';
                
                scriptData.script_variations.forEach((variation, index) => {
                    scriptHtml += `
                        <div class="script-variation p-4 rounded-lg ${index === 0 ? 'selected' : ''}" data-index="${index}">
                            <div class="flex items-start">
                                <input type="radio" id="script_choice_${jobId}_${index}" name="script_choice_${jobId}" class="mt-1.5 h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500" ${index === 0 ? 'checked' : ''}>
                                <div class="ml-3 flex-grow">
                                    <label for="script_choice_${jobId}_${index}" class="block text-md font-bold text-white cursor-pointer">${variation.title}</label>
                                    <p class="mt-2 text-gray-300 script-text">${variation.script_text}</p>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                scriptDetailsEl.innerHTML = scriptHtml;
                scriptDetailsEl.classList.add('expanded');
                
                card.querySelectorAll('.script-variation').forEach(el => {
                    el.addEventListener('click', () => {
                        card.querySelectorAll('.script-variation').forEach(innerEl => innerEl.classList.remove('selected'));
                        el.classList.add('selected');
                        el.querySelector('input[type="radio"]').checked = true;
                    });
                });

                actionsEl.innerHTML = `<button class="generate-video-btn w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">${translations[currentLanguage].btn_generate_video}</button>`;
                card.querySelector('.generate-video-btn').onclick = (e) => {
                    e.stopPropagation();
                    const cardElement = e.target.closest('[data-job-id]');
                    const selectedRadio = cardElement.querySelector('input[name^="script_choice_"]:checked');
                    if(selectedRadio){
                        const selectedVariationDiv = selectedRadio.closest('.script-variation');
                        const scriptText = selectedVariationDiv.querySelector('.script-text').textContent;
                        const scriptTitle = selectedVariationDiv.querySelector('label').textContent;
                        generateMediaForJob(jobId, scriptText, scriptTitle, job.imageUrl);
                    } else {
                        showGlobalMessage(translations[currentLanguage].alert_select_script, 'error');
                    }
                };
            }

            if (scenesToRender) {
                 let scenesHtml = '<h4 class="text-lg font-bold mb-2">Generated Scenes:</h4>';
                 scenesToRender.forEach((scene, i) => {
                    const sceneIndex = i;
                    const sceneStatus = job.scenes?.[sceneIndex]?.gen_status;
                    scenesHtml += `
                        <div class="mt-2 p-2 border-l-4 ${sceneStatus === 'success' ? 'border-green-500' : sceneStatus === 'error' ? 'border-red-500' : 'border-gray-500'}">
                            <div class="flex justify-between items-center">
                                <label class="font-bold">${translations[currentLanguage].label_scene} ${sceneIndex + 1}:</label>
                                <span class="scene-status text-xs" data-scene-index="${sceneIndex}">${sceneStatus || ''}</span>
                            </div>
                            <p class="text-gray-300">${scene.text}</p>
                            <p class="scene-visual-prompt text-xs text-gray-400 mt-1" data-scene-index="${sceneIndex}">Prompt: ${scene.visual}</p>
                            ${sceneStatus === 'error' ? `
                                <div class="flex space-x-2 mt-1">
                                    <button class="retry-scene-btn text-xs bg-red-700 hover:bg-red-600 px-2 py-1 rounded" data-scene-index="${sceneIndex}">${translations[currentLanguage].btn_retry}</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                scriptDetailsEl.innerHTML = scenesHtml;
                scriptDetailsEl.querySelectorAll('.retry-scene-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const sceneIndex = parseInt(e.target.dataset.sceneIndex, 10);
                        retrySceneGeneration(jobId, sceneIndex);
                    };
                });
            }

            if (media_failed) {
                statusEl.textContent = translations[currentLanguage].status_media_failed;
                statusEl.classList.remove('text-gray-400');
                statusEl.classList.add('text-red-400');
                actionsEl.innerHTML = `<button class="generate-video-btn w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">${translations[currentLanguage].btn_retry_media}</button>`;
                card.querySelector('.generate-video-btn').onclick = (e) => {
                    e.stopPropagation();
                    generateImagesForJob(jobId);
                };
            }

            if (ready) {
                statusEl.textContent = job.downloaded ? '‚úÖ WebM Downloaded' : translations[currentLanguage].status_video_ready;
                statusEl.classList.remove('text-gray-400', 'text-red-400');
                statusEl.classList.add('text-green-400');
                scriptDetailsEl.classList.remove('expanded');

                actionsEl.innerHTML = '';
                
                const previewButton = document.createElement('button');
                previewButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg><span>${translations[currentLanguage].btn_preview_video}</span>`;
                previewButton.className = 'flex-1 bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-3 rounded-lg flex items-center justify-center transition text-sm';
                previewButton.onclick = (e) => {
                    e.stopPropagation();
                    showPreview(jobId);
                };
                actionsEl.appendChild(previewButton);

                const downloadWebmButton = document.createElement('button');
                downloadWebmButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg><span>Download WebM</span>`;
                downloadWebmButton.className = 'flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg flex items-center justify-center transition text-sm';
                downloadWebmButton.onclick = async (e) => {
                    e.stopPropagation();
                    const job = videoJobs.find(j => j.id === jobId);
                    if (!job) return;

                    updateCardUI(jobId, { status: 'Rendering WebM...' });
                    try {
                        await preloadImages(job);
                        const webmBlob = await renderAndProceed('download', job);
                        job.downloaded = true;
                        updateCardUI(jobId, { status: '‚úÖ WebM Downloaded', ready: true });
                    } catch (error) {
                        console.error(`Manual download failed for job ${jobId}:`, error);
                        updateCardUI(jobId, { status: '‚ùå Download Failed', ready: true });
                    }
                };
                actionsEl.appendChild(downloadWebmButton);
            }
        }
        
        async function createUGCScriptJob(productName, productDescription, imageBase64s, settings) {
            const jobId = Date.now();
            const job = { 
                id: jobId, 
                topic: productName || "UGC Product Ad", 
                status: 'pending', 
                style: settings.style
            };
            videoJobs.push(job);
            const card = createNewCard(jobId);
            videoCardsContainer.innerHTML = ''; // Clear previous cards
            videoCardsContainer.appendChild(card);

            try {
                updateCardUI(job.id, { title: job.topic, status: translations[currentLanguage].status_generating_script });
                const scriptData = await generateUGCScript(productName, productDescription, imageBase64s, settings.language);
                if (!scriptData || !scriptData.script_variations) throw new Error(translations[currentLanguage].error_script_format);
                
                job.scriptData = scriptData;
                job.status = 'script_ready';
                updateCardUI(job.id, { status: translations[currentLanguage].status_ready_to_generate, scriptData: scriptData });
            } catch(error) {
                console.error(`Error creating UGC script for job #${job.id}:`, error);
                job.status = 'error';
                updateCardUI(job.id, { status: `${translations[currentLanguage].error_generic}: ${error.message}`, error: true });
            }
        }
        
        async function handleRegenerate(jobId, button) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job) return;

            button.disabled = true;
            button.textContent = translations[currentLanguage].status_regenerating;

            const settings = {
                language: languageSelect.value,
                style: job.style
            };
            
            try {
                 const scriptData = await generateUGCScript(job.topic, null, null, settings.language);
                 if (!scriptData || !scriptData.script_variations) throw new Error(translations[currentLanguage].error_script_format);
                
                job.scriptData = scriptData;
                job.status = 'script_ready';
                updateCardUI(job.id, { status: translations[currentLanguage].status_ready_to_generate, scriptData: scriptData });
            } catch (error) {
                console.error(`Error regenerating script for job #${jobId}:`, error);
                job.status = 'error';
                updateCardUI(job.id, { status: `${translations[currentLanguage].error_generic}: ${error.message}`, error: true });
            }
        }

        async function generateMediaForJob(jobId, selectedScriptText, selectedScriptTitle, imageUrl) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job || !selectedScriptText || !selectedScriptTitle) return;

            job.status = 'media_generating';
            updateCardUI(jobId, { status: 'Generating scenes...' });

            try {
                const sceneData = await generateScenesFromScript(selectedScriptText, selectedScriptTitle, job.style, imageUrl);
                job.sceneData = sceneData;

                job.scenes = sceneData.scenes.map(scene => ({ ...scene, gen_status: 'pending' }));

                job.scenes.forEach(scene => scene.zoomDirection = Math.random() < 0.5 ? 'in' : 'out');
            
                await generateImagesForJob(jobId);

            } catch (error) {
                console.error(`Error in media generation pipeline for job #${jobId}:`, error);
                job.status = 'media_failed';
                updateCardUI(jobId, { status: `${translations[currentLanguage].error_generic}: ${error.message}`, media_failed: true });
            }
        }

        async function generateImagesForJob(jobId) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job || !job.scenes) {
                console.error("generateImagesForJob called without job or scenes.");
                return;
            }
            const card = document.querySelector(`[data-job-id="${jobId}"]`);
            let hasError = false;

            updateCardUI(jobId, { status: 'Generating media...', scenesToRender: job.scenes });

            for (let i = 0; i < job.scenes.length; i++) {
                const scene = job.scenes[i];
                if (scene.gen_status === 'success') continue;

                const statusEl = card.querySelector(`.scene-status[data-scene-index="${i}"]`);
                if(statusEl) statusEl.innerHTML = `<div class="loader w-4 h-4 border-2"></div>`;
                scene.gen_status = 'generating';
                
                try {
                    let imageUrl;
                    if (scene.isProductImage && scene.visual.startsWith('http')) {
                        // This is the product image scene, fetch the URL
                        const base64 = await imageUrlToBase64(scene.visual);
                        imageUrl = `data:image/jpeg;base64,${base64}`;
                    } else {
                        // This is a regular scene, generate from prompt
                        imageUrl = await generateImage(scene.visual, job.style);
                    }
                    scene.image = imageUrl;
                    scene.gen_status = 'success';
                    if(statusEl) statusEl.textContent = '‚úÖ';
                } catch (error) {
                    console.error(`Error generating image for scene ${i}:`, error);
                    scene.gen_status = 'error';
                    hasError = true;
                    if(statusEl) statusEl.textContent = '‚ùå';
                }
            }
            
            updateCardUI(jobId, { scenesToRender: job.scenes });

            if (hasError) {
                job.status = 'media_failed';
                updateCardUI(jobId, { media_failed: true });
            } else {
                await generateAudioForJob(jobId);
            }
        }

        async function generateAudioForJob(jobId) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job) return;

            try {
                updateCardUI(jobId, { status: translations[currentLanguage].status_generating_audio });
                const allTexts = job.scenes.map(s => s.text);
                const outroText = outroTextInput.value.trim();
                if (outroText && allTexts.length > 0) {
                    allTexts[allTexts.length - 1] = allTexts[allTexts.length - 1].trim() + " \n\n" + outroText;
                }
                
                const settings = {
                    apiKey: apiKeyInput.value.trim(),
                    languageCode: langCodeMap[languageSelect.value],
                    voice: voiceSelect.value,
                    geminiModel: geminiModelSelection.value
                };

                if (settings.voice.startsWith('gemini-native')) {
                    const fullScript = allTexts.join(' \n\n ');
                    const nativeVoice = nativeVoiceSelection.value;
                    const fullAudioSrc = await getGeminiTTSAudio(fullScript, settings.apiKey, nativeVoice, settings.geminiModel);
                    job.fullAudioSrc = fullAudioSrc;
                    
                    const tempAudio = new Audio(fullAudioSrc);
                    await new Promise((resolve, reject) => {
                        tempAudio.onloadedmetadata = () => {
                            const totalDuration = tempAudio.duration;
                            const totalChars = allTexts.reduce((sum, text) => sum + text.length, 0);
                            let accumulatedTime = 0;
                            job.scenes.forEach((scene, i) => {
                                const sceneDuration = totalChars > 0 ? (allTexts[i].length / totalChars) * totalDuration : 0;
                                scene.startTime = accumulatedTime;
                                scene.endTime = accumulatedTime + sceneDuration;
                                accumulatedTime += sceneDuration;
                            });
                            resolve();
                        };
                        tempAudio.onerror = reject;
                    });
                } else {
                    const { audioSrc, timepoints } = await getGoogleTTSAudioWithTimestamps(allTexts, settings.voice, settings.languageCode, settings.apiKey);
                    job.fullAudioSrc = audioSrc;

                    const tempAudio = new Audio(audioSrc);
                    await new Promise((resolve, reject) => {
                        tempAudio.onloadedmetadata = () => {
                            const totalDuration = tempAudio.duration;
                            const sceneTimings = [];
                            for (let i = 0; i < allTexts.length; i++) {
                                const startTime = timepoints[i] ? timepoints[i].timeSeconds : (i > 0 ? sceneTimings[i-1].endTime : 0);
                                const endTime = (i + 1 < timepoints.length) ? timepoints[i + 1].timeSeconds : totalDuration;
                                sceneTimings.push({ startTime, endTime });
                            }
                            job.scenes.forEach((scene, i) => {
                                if (sceneTimings[i]) {
                                    scene.startTime = sceneTimings[i].startTime;
                                    scene.endTime = sceneTimings[i].endTime;
                                }
                            });
                            resolve();
                        };
                        tempAudio.onerror = (e) => {
                            console.error("Error loading TTS audio for timing calculation:", e);
                            reject(e);
                        };
                    });
                }
                
                job.status = 'ready';
                updateCardUI(jobId, { ready: true });
                
                // If this is a batch job, auto-render and download
                if (job.isBatch) {
                    autoRenderAndDownload(jobId);
                }

            } catch (error) {
                console.error(`Error generating audio for job #${jobId}:`, error);
                job.status = 'media_failed';
                updateCardUI(jobId, { status: `${translations[currentLanguage].error_audio_generation}: ${error.message}`, media_failed: true });
            }
        }
        
        async function retrySceneGeneration(jobId, sceneIndex) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job || !job.scenes?.[sceneIndex]) return;

            const scene = job.scenes[sceneIndex];
            const card = document.querySelector(`[data-job-id="${jobId}"]`);
            const statusEl = card.querySelector(`.scene-status[data-scene-index="${sceneIndex}"]`);
            const retryBtnContainer = card.querySelector(`.retry-scene-btn[data-scene-index="${sceneIndex}"]`).parentElement;

            if(statusEl) statusEl.innerHTML = `<div class="loader w-4 h-4 border-2"></div>`;
            if(retryBtnContainer) retryBtnContainer.innerHTML = '';
            scene.gen_status = 'generating';
                
            try {
                let imageUrl;
                if (scene.isProductImage && scene.visual.startsWith('http')) {
                    const base64 = await imageUrlToBase64(scene.visual);
                    imageUrl = `data:image/jpeg;base64,${base64}`;
                } else {
                    imageUrl = await generateImage(scene.visual, job.style);
                }
                scene.image = imageUrl;
                scene.gen_status = 'success';
                if(statusEl) statusEl.textContent = '‚úÖ';

                const allSuccess = job.scenes.every(s => s.gen_status === 'success');
                if (allSuccess) {
                    await generateAudioForJob(jobId);
                }

            } catch (error) {
                console.error(`Error retrying image for scene ${sceneIndex}:`, error);
                scene.gen_status = 'error';
                if(statusEl) statusEl.textContent = '‚ùå';
                if(retryBtnContainer) {
                    retryBtnContainer.innerHTML = `<button class="retry-scene-btn text-xs bg-red-700 hover:bg-red-600 px-2 py-1 rounded" data-scene-index="${sceneIndex}">${translations[currentLanguage].btn_retry}</button>`;
                    retryBtnContainer.querySelector('.retry-scene-btn').onclick = (e) => {
                        e.stopPropagation();
                        retrySceneGeneration(jobId, sceneIndex);
                    };
                }
            }
        }

        async function showPreview(jobId) {
            currentJob = videoJobs.find(job => job.id === jobId);
            if (!currentJob || currentJob.status !== 'ready') return;

            previewTitle.textContent = currentJob.topic;
            populatePreviewPlayground(currentJob);

            settingsView.classList.add('hidden');
            previewView.classList.remove('hidden');

            renderingLoader.classList.remove('hidden');
            renderingLoaderText.textContent = 'Loading images...';
            try {
                await preloadImages(currentJob);
            } catch (error) {
                console.error("Error preloading images:", error);
                showGlobalMessage("Failed to load images for preview. Please try again.", 'error');
                renderingLoader.classList.add('hidden');
                return;
            }
            renderingLoader.classList.add('hidden');

            videoPlayer.classList.remove('hidden');
            playOverlay.classList.remove('hidden');
            pauseButtonContainer.classList.add('hidden');
            
            drawStaticScene(0);
        }

        async function preloadImages(job) {
            const promises = job.scenes.map(scene => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    scene.imageElement = img;
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = scene.image;
                });
            });
            await Promise.all(promises);
        }

        function populatePreviewPlayground(job) {
            previewPlaygroundGrid.innerHTML = '';
            job.scenes.forEach((scene, index) => {
                const card = previewSceneTemplate.content.cloneNode(true).firstElementChild;
                const titleText = `${translations[currentLanguage].label_scene} ${index + 1}`;
                card.querySelector('.scene-title').textContent = titleText;
                card.querySelector('.scene-image').src = scene.image;
                card.querySelector('.scene-prompt').value = scene.visual;
                
                const regenerateBtn = card.querySelector('.regenerate-preview-btn');
                regenerateBtn.dataset.index = index;

                const uploadInput = card.querySelector('.scene-upload-input');
                const uploadLabel = card.querySelector('.upload-btn');
                const inputId = `upload-input-${job.id}-${index}`;
                uploadInput.id = inputId;
                uploadLabel.setAttribute('for', inputId);

                uploadInput.addEventListener('change', (event) => handleImageUpload(event, index));

                previewPlaygroundGrid.appendChild(card);
            });
        }

        async function handleImageUpload(event, index) {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                return;
            }

            const sceneCard = previewPlaygroundGrid.querySelector(`[for="upload-input-${currentJob.id}-${index}"]`).closest('.bg-gray-700');
            const imageEl = sceneCard.querySelector('.scene-image');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                const newImageUrl = e.target.result;
                currentJob.scenes[index].image = newImageUrl;
                currentJob.scenes[index].isUploaded = true; // Mark as uploaded
                imageEl.src = newImageUrl;

                const img = new Image();
                img.crossOrigin = "anonymous";
                currentJob.scenes[index].imageElement = img;
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = newImageUrl;
                });
                
                if (index === activeSceneIndex || !isPlaying) {
                    await drawStaticScene(index);
                }
            };
            reader.readAsDataURL(file);
        }


        async function regeneratePreviewImage(index) {
            const sceneCard = previewPlaygroundGrid.querySelector(`.regenerate-preview-btn[data-index="${index}"]`).closest('.bg-gray-700');
            const loader = sceneCard.querySelector('.scene-loader');
            const imageEl = sceneCard.querySelector('.scene-image');
            const promptEl = sceneCard.querySelector('.scene-prompt');

            loader.classList.remove('hidden');
            try {
                const originalPrompt = promptEl.value;
                const refinedPrompt = await refinePrompt(originalPrompt);
                promptEl.value = refinedPrompt;
                
                const newImageUrl = await generateImage(refinedPrompt, currentJob.style);

                if (newImageUrl) {
                    currentJob.scenes[index].image = newImageUrl;
                    currentJob.scenes[index].visual = refinedPrompt;
                    currentJob.scenes[index].isUploaded = false; // Mark as AI-generated
                    imageEl.src = newImageUrl;
                    
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    currentJob.scenes[index].imageElement = img;
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.src = newImageUrl;
                    });
                    
                    if (index === activeSceneIndex || !isPlaying) {
                        await drawStaticScene(index);
                    }
                }
            } catch (error) {
                showGlobalMessage(`${translations[currentLanguage].error_image_regeneration}: ${error.message}`, 'error');
            } finally {
                loader.classList.add('hidden');
            }
        }

        function stopPlayback(isRendering = false) {
            if (!isPlaying) return;
            isPlaying = false;
            isPaused = false;
            cancelAnimationFrame(animationFrameId);
            audioPlayer.pause();
            
            if (isRendering && mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            // Show static thumbnail and play button
            canvas.classList.add('hidden');
            videoPlayer.classList.remove('hidden');
            playOverlay.classList.remove('hidden');
            pauseButtonContainer.classList.add('hidden');
            if (currentJob && currentJob.scenes && currentJob.scenes.length > 0) {
                drawStaticScene(0);
            }
        }

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused;
            if (isPaused) {
                audioPlayer.pause();
                cancelAnimationFrame(animationFrameId);
                if(mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.pause();
                pauseButton.innerHTML = playIcon;
            } else {
                audioPlayer.play();
                if(mediaRecorder && mediaRecorder.state === 'paused') mediaRecorder.resume();
                pauseButton.innerHTML = pauseIcon;
                timestampPlaybackLoop();
            }
        }

        function initAudioGraph() {
            if (audioGraphInitialized) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                voiceSourceNode = audioContext.createMediaElementSource(audioPlayer);
                voiceGainNode = audioContext.createGain();
                mediaStreamDestination = audioContext.createMediaStreamDestination();

                voiceSourceNode.connect(voiceGainNode);
                voiceGainNode.connect(audioContext.destination);
                voiceGainNode.connect(mediaStreamDestination);

                audioGraphInitialized = true;
            } catch (e) {
                console.error("Failed to initialize audio graph:", e);
                audioGraphInitialized = false;
                showGlobalMessage(translations[currentLanguage].error_audio_init, 'error');
            }
        }

        function startPlayback(isRendering = false) {
            if (!currentJob) return;
            
            initAudioGraph();
            if (!audioGraphInitialized) return;

            canvas.classList.remove('hidden');
            videoPlayer.classList.add('hidden');

            if (!isRendering) {
                pauseButtonContainer.classList.remove('hidden');
                pauseButton.innerHTML = pauseIcon;
            }

            voiceGainNode.gain.value = 1.0;

            isPlaying = true;
            isPaused = false;
            
            audioPlayer.src = currentJob.fullAudioSrc;
            audioPlayer.playbackRate = parseFloat(playbackSpeedSelect.value);
            audioPlayer.preservesPitch = false; // This ensures pitch changes with speed
            audioPlayer.onended = () => stopPlayback(isRendering);
            audioPlayer.play().catch(err => {
                console.error("Full audio playback failed.", err);
                stopPlayback(isRendering);
            });
            timestampPlaybackLoop();
        }

        function timestampPlaybackLoop() {
            if (!isPlaying || isPaused) {
                return;
            }
            
            const currentTime = audioPlayer.currentTime;
            activeSceneIndex = -1;
            for (let i = 0; i < currentJob.scenes.length; i++) {
                if (currentTime >= currentJob.scenes[i].startTime && currentTime < currentJob.scenes[i].endTime) {
                    activeSceneIndex = i;
                    break;
                }
            }

            drawAnimatedFrame(currentTime);
            
            animationFrameId = requestAnimationFrame(timestampPlaybackLoop);
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function drawAnimatedFrame(currentTime) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scenes = currentJob.scenes;
            const doTransition = enableTransitionCheckbox.checked;
            const transitionDuration = doTransition ? parseFloat(transitionDurationSlider.value) : 0;
            
            if (activeSceneIndex === -1) {
                 if (scenes.length > 0 && currentTime < scenes[0].startTime) {
                    drawSceneWithZoom(scenes[0], 0, 1);
                } else if (scenes.length > 0) {
                    drawSceneWithZoom(scenes[scenes.length - 1], 1, 1);
                }
                return;
            }

            const currentSceneData = scenes[activeSceneIndex];
            const nextSceneData = (activeSceneIndex + 1 < scenes.length) ? scenes[activeSceneIndex + 1] : null;

            const sceneDuration = currentSceneData.endTime - currentSceneData.startTime;
            const elapsedInScene = currentTime - currentSceneData.startTime;

            drawSceneWithZoom(currentSceneData, elapsedInScene, sceneDuration);

            const timeUntilEnd = currentSceneData.endTime - currentTime;
            if (doTransition && nextSceneData && timeUntilEnd < transitionDuration && sceneDuration > transitionDuration) {
                const transitionProgress = 1.0 - (timeUntilEnd / transitionDuration);
                const easedProgress = easeInOutCubic(transitionProgress);
                
                ctx.globalAlpha = easedProgress;
                drawSceneWithZoom(nextSceneData, 0, (nextSceneData.endTime - nextSceneData.startTime));
                ctx.globalAlpha = 1.0;
            }
            
            const showSubtitles = showSubtitleCheckbox.checked;
            if (showSubtitles && currentSceneData.text) {
                drawSubtitles(currentSceneData.text);
            }
        }

        function drawSceneWithZoom(scene, elapsed, duration) {
            const image = scene.imageElement;
            if (!image || !image.complete || image.naturalHeight === 0) {
                return;
            }

            const doZoom = enableZoomCheckbox.checked;
            const zoomAmount = parseFloat(zoomIntensitySlider.value) / 100.0;
            const progress = duration > 0 ? elapsed / duration : 0;
            const easedProgress = easeInOutCubic(progress);
            const canvasAspect = canvas.width / canvas.height;
            const imageAspect = image.naturalWidth / image.naturalHeight;

            let sx, sy, sw, sh, dx, dy, dw, dh;

            if (scene.isUploaded) {
                // --- 'Contain' logic for uploaded images ---
                
                // 1. Draw blurred background
                ctx.save();
                ctx.filter = 'blur(20px) brightness(0.6)';
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                ctx.restore();

                // 2. Set source rect to the whole image
                sx = 0;
                sy = 0;
                sw = image.naturalWidth;
                sh = image.naturalHeight;

                // 3. Calculate destination rect for 'contain'
                if (imageAspect > canvasAspect) {
                    dw = canvas.width;
                    dh = dw / imageAspect;
                    dx = 0;
                    dy = (canvas.height - dh) / 2;
                } else {
                    dh = canvas.height;
                    dw = dh * imageAspect;
                    dy = 0;
                    dx = (canvas.width - dw) / 2;
                }

                // 4. Apply zoom to destination rect
                if (doZoom) {
                    const scale = scene.zoomDirection === 'in' 
                        ? 1 + (zoomAmount * easedProgress) 
                        : (1 + zoomAmount) - (zoomAmount * easedProgress);
                    
                    const newDw = dw * scale;
                    const newDh = dh * scale;
                    const newDx = dx - (newDw - dw) / 2;
                    const newDy = dy - (newDh - dh) / 2;
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(dx, dy, dw, dh); // Clip to original destination bounds
                    ctx.clip();
                    ctx.drawImage(image, sx, sy, sw, sh, newDx, newDy, newDw, newDh);
                    ctx.restore();
                } else {
                    ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
                }

            } else {
                // --- 'Cover' logic for AI-generated images ---
                
                // 1. Set destination rect to the whole canvas
                dx = 0;
                dy = 0;
                dw = canvas.width;
                dh = canvas.height;

                // 2. Calculate source rect for 'cover'
                if (imageAspect > canvasAspect) {
                    sh = image.naturalHeight;
                    sw = sh * canvasAspect;
                    sx = (image.naturalWidth - sw) / 2;
                    sy = 0;
                } else {
                    sw = image.naturalWidth;
                    sh = sw / canvasAspect;
                    sx = 0;
                    sy = (image.naturalHeight - sh) / 2;
                }

                // 3. Apply zoom to source rect
                if (doZoom) {
                    const scale = scene.zoomDirection === 'in' 
                        ? 1 / (1 + (zoomAmount * easedProgress)) 
                        : 1 / ((1 + zoomAmount) - (zoomAmount * easedProgress));
                    
                    const newSw = sw * scale;
                    const newSh = sh * scale;
                    const newSx = sx + (sw - newSw) / 2;
                    const newSy = sy + (sh - newSh) / 2;
                    
                    ctx.drawImage(image, newSx, newSy, newSw, newSh, dx, dy, dw, dh);
                } else {
                    ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
                }
            }
        }


        async function drawStaticScene(index) {
            if (!currentJob || !currentJob.scenes || !currentJob.scenes[index]) return;
            const scene = currentJob.scenes[index];
            if (!scene.imageElement || !scene.imageElement.complete) {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                videoImage.src = canvas.toDataURL('image/png');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSceneWithZoom(scene, 0, 1);
            
            const showSubtitles = showSubtitleCheckbox.checked;
            if (showSubtitles && scene.text) {
                drawSubtitles(scene.text);
            }
            videoImage.src = canvas.toDataURL('image/png');
        }

        function drawSubtitles(text) {
            const fontFamily = fontStyleSelect.value;
            const fontSize = parseInt(fontSizeInput.value, 10);
            const watermarkText = watermarkInput.value.trim();

            ctx.font = `bold ${fontSize}px '${fontFamily}', sans-serif`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            ctx.shadowColor = 'rgba(0,0,0,0.8)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            const x = canvas.width / 2;
            const y = canvas.height - 150;
            
            const words = text.split(' ');
            let line = '';
            let lines = [];
            const maxWidth = canvas.width * 0.9;

            for(let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            const lineHeight = fontSize * 1.2;
            const startY = y - ((lines.length - 1) * lineHeight);

            for(let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], x, startY + (i * lineHeight));
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            if (watermarkText) {
                ctx.font = `bold 40px '${fontFamily}', sans-serif`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'alphabetic';
                ctx.fillText(watermarkText, canvas.width - 30, canvas.height - 30);
            }
        }

        function deleteCard(jobId) {
            const card = document.querySelector(`[data-job-id="${jobId}"]`);
            if (card) {
                card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                card.style.opacity = '0';
                card.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    card.remove();
                    videoJobs = videoJobs.filter(j => j.id !== jobId);
                }, 300);
            }
        }

        function createNewCard(jobId) {
            const card = videoCardTemplate.content.cloneNode(true).firstElementChild;
            card.dataset.jobId = jobId;
            
            card.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteCard(jobId);
            });

            return card;
        }
        
        function executeRecording(action, reject) {
            const frameRate = 30;
            let renderInterval;

            audioPlayer.src = currentJob.fullAudioSrc;

            const startRecording = () => {
                audioPlayer.removeEventListener('canplaythrough', startRecording);
                audioPlayer.removeEventListener('error', recordingFailed);

                voiceGainNode.gain.value = 1.0;
                
                mediaRecorder.start();
                audioPlayer.play().catch(err => {
                    console.error("Audio playback failed on start.", err);
                    if (renderInterval) clearInterval(renderInterval);
                    if (mediaRecorder.state !== 'inactive') mediaRecorder.stop();
                    reject(err);
                });

                renderInterval = setInterval(() => {
                    drawAnimatedFrame(audioPlayer.currentTime);
                }, 1000 / frameRate);
            };

            const recordingFailed = (e) => {
                audioPlayer.removeEventListener('canplaythrough', startRecording);
                audioPlayer.removeEventListener('error', recordingFailed);
                console.error("Audio player error before recording:", e);
                reject(new Error("Audio player failed to load media."));
            };

            audioPlayer.addEventListener('canplaythrough', startRecording);
            audioPlayer.addEventListener('error', recordingFailed);

            audioPlayer.onended = () => {
                clearInterval(renderInterval);
                if (mediaRecorder.state !== 'inactive') mediaRecorder.stop();
            };

            setTimeout(() => {
                if (mediaRecorder.state === 'inactive' && !audioPlayer.ended) {
                     recordingFailed(new Error("Audio loading timed out."));
                }
            }, 10000); 
        }

        function renderAndProceed(action, jobToRender = null) {
            const job = jobToRender || currentJob;
            if (!job) return Promise.reject("No job to render.");

            const originalCurrentJob = currentJob;
            currentJob = job;

            initAudioGraph();
            if (!audioGraphInitialized) {
                showGlobalMessage(translations[currentLanguage].error_audio_init, 'error');
                currentJob = originalCurrentJob;
                return Promise.reject("Audio context not initialized.");
            }

            const isBulkDownload = action === 'download_mp4';
            if (!isBulkDownload) {
                renderingLoader.classList.remove('hidden');
                renderingLoaderText.textContent = action === 'upload' 
                    ? translations[currentLanguage].rendering_for_upload 
                    : translations[currentLanguage].rendering_for_download;
            }

            canvas.classList.remove('hidden');
            videoPlayer.classList.add('hidden');

            const canvasStream = canvas.captureStream(30);
            const audioStream = mediaStreamDestination.stream;
            const combinedStream = new MediaStream([...canvasStream.getTracks(), ...audioStream.getTracks()]);
            
            recordedChunks = [];
            
            let options = { 
                mimeType: 'video/webm; codecs=vp9,opus',
                audioBitsPerSecond: 128000,
                videoBitsPerSecond: 2500000
            };
            
            try {
                mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                console.error("MediaRecorder setup failed:", e);
                if (!isBulkDownload) renderingLoader.classList.add('hidden');
                showGlobalMessage("Failed to initialize video recorder. Your browser might not support it.", 'error');
                currentJob = originalCurrentJob;
                return Promise.reject("MediaRecorder setup failed.");
            }
            
            return new Promise((resolve, reject) => {
                mediaRecorder.onstop = async () => {
                    if (!isBulkDownload) {
                        renderingLoader.classList.add('hidden');
                        canvas.classList.add('hidden');
                        videoPlayer.classList.remove('hidden');
                        if (currentJob) drawStaticScene(0);
                    }

                    const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    
                    if (videoBlob.size === 0) {
                        reject(new Error("Rendered video file is empty."));
                        return;
                    }

                    if (action === 'download') {
                        const videoUrl = URL.createObjectURL(videoBlob);
                        const tempLink = document.createElement('a');
                        tempLink.href = videoUrl;
                        tempLink.download = `${job.topic.trim().replace(/\s/g, '_')}.webm`;
                        document.body.appendChild(tempLink);
                        tempLink.click();
                        document.body.removeChild(tempLink);
                        URL.revokeObjectURL(videoUrl);
                    } else if (action === 'upload') {
                        showUploadModal();
                    }
                    
                    resolve(videoBlob);
                    currentJob = originalCurrentJob;
                };
                 mediaRecorder.onerror = (event) => {
                    console.error("MediaRecorder error:", event.error);
                    if (!isBulkDownload) renderingLoader.classList.add('hidden');
                    showGlobalMessage("An error occurred during video rendering.", 'error');
                    currentJob = originalCurrentJob;
                    reject(event.error);
                };
                executeRecording(action, reject);
            });
        }


        // --- YouTube Upload Modal Functions ---
        
        function setUploadStatus(message, type = 'info') {
            uploadStatusMessage.innerHTML = message;
            uploadStatusMessage.classList.remove('text-green-400', 'text-red-400', 'text-gray-400');
            if (type === 'success') uploadStatusMessage.classList.add('text-green-400');
            else if (type === 'error') uploadStatusMessage.classList.add('text-red-400');
            else uploadStatusMessage.classList.add('text-gray-400');
        }

        function setUploadButtonState(loading, text) {
            uploadConfirmBtn.disabled = loading;
            uploadBtnLoader.classList.toggle('hidden', !loading);
            uploadBtnIcon.classList.toggle('hidden', loading);
            if (text) uploadBtnText.textContent = text;
        }

        function resetUploadModal() {
            uploadContentForm.classList.add('hidden');
            uploadVideoTitle.value = '';
            uploadVideoDescription.value = '';
            uploadConfirmBtn.disabled = true;
            setUploadButtonState(false, "Upload to YouTube");
            setUploadStatus('');
            generatedVideoFile = null;
        }

        async function showUploadModal() {
            resetUploadModal();
            uploadModal.classList.remove('hidden');
            
            uploadCategorySelector.innerHTML = '';
            for (const option of categorySelect.options) {
                uploadCategorySelector.add(option.cloneNode(true));
            }
            uploadCategorySelector.value = categorySelect.value;
            
            const videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
            const fileName = `${currentJob.topic.trim().replace(/\s/g, '_')}.webm`;
            generatedVideoFile = new File([videoBlob], fileName, { type: 'video/webm' });
            uploadVideoFilename.textContent = fileName;
            
            await fetchUploadChannels();
        }

        function hideUploadModal() {
            uploadModal.classList.add('hidden');
        }

        async function fetchUploadChannels() {
            const apiKey = polveApiKeyInput.value.trim();
            if (!apiKey) return;
            
            setUploadStatus('Fetching channels...', 'info');
            uploadChannelSelector.disabled = true;
            uploadChannelSelector.innerHTML = '<option>Loading...</option>';

            try {
                const response = await fetch(`${UPLOAD_API_BASE_URL}/youtube-api`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'get_channels', api_key: apiKey })
                });
                const result = await response.json();
                if (!response.ok || !result.success) throw new Error(result.error || 'Could not fetch channels');
                
                uploadChannelSelector.innerHTML = '<option value="">-- Select Channel --</option>';
                result.channels.forEach(channel => {
                    const option = document.createElement('option');
                    option.value = channel.id;
                    option.textContent = `${channel.channelName} (@${channel.username})`;
                    uploadChannelSelector.appendChild(option);
                });
                uploadChannelSelector.disabled = false;
                setUploadStatus('Channels fetched successfully.', 'success');
                
                await analyzeScriptForUpload();

            } catch (error) {
                setUploadStatus(error.message, 'error');
                uploadChannelSelector.innerHTML = '<option>Error fetching channels</option>';
            }
        }

        async function analyzeScriptForUpload() {
            if (!currentJob || !currentJob.scenes) {
                return setUploadStatus('No script data to analyze.', 'error');
            }
            
            setUploadStatus('Analyzing script for metadata...', 'info');

            try {
                const categories = Array.from(uploadCategorySelector.options)
                    .filter(opt => opt.value)
                    .map(opt => ({ id: opt.value, name: opt.textContent.trim().substring(2) }));
                const categoryListForPrompt = JSON.stringify(categories);

                const scriptSummary = currentJob.scenes.map(s => s.text).join(' ').substring(0, 1000);
                const languageName = langNameMap[languageSelect.value];

                const prompt = `Based on the following YouTube Short script, generate metadata for the upload in ${languageName}.
                
                Topic: "${currentJob.topic}"
                Script Summary: "${scriptSummary}"

                Your task is to create:
                1.  **title**: A catchy, viral-style title in ${languageName}, maximum 100 characters.
                2.  **description**: An engaging description in ${languageName} with relevant hashtags.
                3.  **categoryId**: The most appropriate category ID from this list: ${categoryListForPrompt}

                Respond with a single, valid JSON object with the keys "title", "description", and "categoryId". Do not include any other text or markdown.`;
                
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                const geminiApiKey = ""; // Canvas provided
                const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;

                const response = await fetch(geminiApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates[0]?.content.parts[0]) {
                    const textContent = result.candidates[0].content.parts[0].text;
                    const jsonString = textContent.replace(/```json|```/g, '').trim();
                    const content = JSON.parse(jsonString);
                    
                    uploadVideoTitle.value = content.title || currentJob.topic;
                    uploadVideoDescription.value = content.description || '';
                    if (content.categoryId && Array.from(uploadCategorySelector.options).some(opt => opt.value === content.categoryId)) {
                        uploadCategorySelector.value = content.categoryId;
                    }

                    uploadVideoTitle.dispatchEvent(new Event('input'));
                    uploadVideoDescription.dispatchEvent(new Event('input'));

                    uploadContentForm.classList.remove('hidden');
                    uploadConfirmBtn.disabled = false;
                    setUploadStatus('Script analyzed successfully.', 'success');
                } else {
                    throw new Error("Could not get valid data from Gemini API");
                }
            } catch (error) {
                setUploadStatus(`Analysis error: ${error.message}`, 'error');
                uploadVideoTitle.value = currentJob.topic;
                uploadContentForm.classList.remove('hidden');
                uploadConfirmBtn.disabled = false;
            }
        }


        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function confirmUpload() {
            const userApiKey = polveApiKeyInput.value.trim();
            const selectedChannelId = uploadChannelSelector.value;
            const title = uploadVideoTitle.value.trim();

            if (!generatedVideoFile || !userApiKey || !title || !selectedChannelId) {
                return setUploadStatus('Please fill all required fields: Channel and Title.', 'error');
            }

            setUploadButtonState(true, "Uploading...");
            setUploadStatus('Preparing video for upload...', 'info');

            try {
                const videoBase64 = await blobToBase64(generatedVideoFile);
                
                const payload = {
                    action: 'upload',
                    api_key: userApiKey,
                    channelId: selectedChannelId,
                    title: title,
                    description: uploadVideoDescription.value.trim(),
                    privacyStatus: uploadPrivacySelector.value,
                    categoryId: uploadCategorySelector.value,
                    videoFile: {
                        data: videoBase64,
                        name: generatedVideoFile.name
                    }
                };
                
                setUploadStatus('Uploading video...', 'info');

                const response = await fetch(`${UPLOAD_API_BASE_URL}/youtube-api`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (!response.ok || !result.success) throw new Error(result.error || `Server error: ${response.status}`);
                
                setUploadStatus(`‚úÖ Upload successful! <a href="${result.youtubeUrl}" target="_blank" class="text-blue-400 hover:underline">View Video</a>`, 'success');
                setUploadButtonState(false, "Upload Complete");
                setTimeout(hideUploadModal, 3000);

            } catch (error) {
                setUploadStatus(`‚ùå Upload failed: ${error.message}`, 'error');
                setUploadButtonState(false, "Try Again");
            }
        }

        // --- Event Listeners ---
        window.addEventListener('load', () => {
            setLanguage(currentLanguage);
            populateNativeVoiceDropdowns();
            populateStyleOptions();
        });

        languageSelect.addEventListener('change', () => {
            updateVoiceOptions();
            updateDefaultOutro();
            if (languageSelect.value === 'en') {
                playbackSpeedSelect.value = '1';
            } else {
                playbackSpeedSelect.value = '1.25';
            }
        });
        
        voiceSelect.addEventListener('change', toggleGeminiConfig);

        animationHeader.addEventListener('click', () => {
            animationContainer.classList.toggle('expanded');
            animationChevron.classList.toggle('chevron-rotated');
        });

        subtitleHeader.addEventListener('click', () => {
            subtitleContainer.classList.toggle('expanded');
            subtitleChevron.classList.toggle('chevron-rotated');
        });
        
        youtubeHeader.addEventListener('click', () => {
            youtubeContainer.classList.toggle('expanded');
            youtubeChevron.classList.toggle('chevron-rotated');
        });
        
        function handleGenerateUGC() {
            const userApiKey = apiKeyInput.value.trim();
            if (!userApiKey) { 
                showGlobalMessage(translations[currentLanguage].alert_api_key, 'error'); 
                return; 
            }

            const productName = ugcProductNameInput.value.trim();
            const productDescription = ugcProductDescriptionInput.value.trim();
            if (!productName && ugcImageBase64s.length === 0) {
                showGlobalMessage(translations[currentLanguage].alert_ugc_input, 'error');
                return;
            }
            
            const settings = {
                apiKey: userApiKey,
                language: languageSelect.value,
                voice: voiceSelect.value,
                category: categorySelect.options[categorySelect.selectedIndex].text,
                style: styleSelect.value
            };

            generateUGCBtn.disabled = true;
            generateUGCBtn.classList.add('opacity-50');

            (async () => {
                await createUGCScriptJob(productName, productDescription, ugcImageBase64s, settings);
                generateUGCBtn.disabled = false;
                generateUGCBtn.classList.remove('opacity-50');
                ugcProductNameInput.value = '';
                ugcProductDescriptionInput.value = '';
                ugcProductImageInput.value = '';
                ugcImagePreview.innerHTML = '';
                ugcImageBase64s = [];
            })();
        }
        
        ugcProductImageInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (!files.length) return;

            ugcImagePreview.innerHTML = '';
            ugcImageBase64s = [];
            
            const filePromises = Array.from(files).map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.className = 'h-24 w-24 object-cover rounded-lg';
                        ugcImagePreview.appendChild(img);
                        ugcImageBase64s.push(e.target.result.split(',')[1]);
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            });

            Promise.all(filePromises).catch(error => console.error("Error reading files:", error));
        });

        generateUGCBtn.addEventListener('click', handleGenerateUGC);

        backToDashboardBtn.addEventListener('click', () => {
            previewView.classList.add('hidden');
            settingsView.classList.remove('hidden');
            if (isPlaying) stopPlayback();
            currentJob = null;
        });
        
        playOverlay.addEventListener('click', () => startPlayback(false));
        pauseButton.addEventListener('click', togglePause);
        downloadBtn.addEventListener('click', () => renderAndProceed('download'));

        playbackSpeedSelect.addEventListener('change', () => {
            if (audioPlayer) {
                audioPlayer.playbackRate = parseFloat(playbackSpeedSelect.value);
                audioPlayer.preservesPitch = false; 
            }
        });

        downloadThumbnailBtn.addEventListener('click', async () => {
            if (!currentJob || !currentJob.scenes || !currentJob.scenes[0]) return;
            
            await drawStaticScene(0);

            const tempLink = document.createElement('a');
            tempLink.download = `${currentJob.topic.trim().replace(/\s/g, '_')}_thumbnail.png`;
            tempLink.href = canvas.toDataURL('image/png', 1.0); 
            document.body.appendChild(tempLink);
            tempLink.click();
            document.body.removeChild(tempLink);
        });

        previewPlaygroundGrid.addEventListener('click', (e) => {
            const regenerateBtn = e.target.closest('.regenerate-preview-btn');
            if (regenerateBtn) {
                const index = regenerateBtn.dataset.index;
                regeneratePreviewImage(parseInt(index, 10));
            }
        });
        
        langThBtn.addEventListener('click', () => setLanguage('th'));
        langEnBtn.addEventListener('click', () => setLanguage('en'));

        // --- Upload Modal Event Listeners ---
        uploadToYouTubeBtn.addEventListener('click', () => {
            if (!polveApiKeyInput.value.trim()) {
                showGlobalMessage(translations[currentLanguage].alert_polve_api_key, 'error');
                return;
            }
            renderAndProceed('upload');
        });
        
        closeUploadModalBtn.addEventListener('click', hideUploadModal);
        uploadModalOverlay.addEventListener('click', hideUploadModal);
        uploadConfirmBtn.addEventListener('click', confirmUpload);

        uploadVideoTitle.addEventListener('input', () => {
            uploadTitleCounter.textContent = `${uploadVideoTitle.value.length}/100`;
        });
        uploadVideoDescription.addEventListener('input', () => {
            uploadDescriptionCounter.textContent = `${uploadVideoDescription.value.length}/5000`;
        });

        // --- Batch Processing Logic ---

        batchCsvInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                csvFileNameEl.textContent = file.name;
            } else {
                csvFileNameEl.textContent = '';
            }
        });

        batchProcessBtn.addEventListener('click', () => {
             const file = batchCsvInput.files[0];
             if (!file) {
                 showGlobalMessage(translations[currentLanguage].alert_select_csv, 'error');
                 return;
             }
             const reader = new FileReader();
             reader.onload = async (event) => {
                 try {
                     const csvData = event.target.result;
                     const parsedData = parseCSV(csvData);
                     await handleBatchProcess(parsedData);
                 } catch (error) {
                     console.error("Error processing CSV file:", error);
                     showGlobalMessage(`Failed to parse CSV: ${error.message}`, 'error');
                 }
             };
             reader.readAsText(file);
        });

        async function handleBatchProcess(data) {
            if (!data || data.length < 2) {
                showGlobalMessage("CSV file is empty or contains only a header.", 'error');
                return;
            }

            const userApiKey = apiKeyInput.value.trim();
            if (!userApiKey) {
                showGlobalMessage(translations[currentLanguage].alert_api_key, 'error');
                return;
            }

            videoCardsContainer.innerHTML = '';
            videoJobs = [];
            batchProcessBtn.disabled = true;
            downloadAllMp4Btn.disabled = true;
            batchProcessBtn.querySelector('span').textContent = translations[currentLanguage].processing_batch;

            const headers = data[0].map(h => h.trim().toLowerCase().replace(/"/g, ''));
            const productNameIndex = headers.indexOf('product title');
            const productDescriptionIndex = headers.indexOf('product description');
            const imageUrlIndex = headers.indexOf('main image url');

            if (productNameIndex === -1 || imageUrlIndex === -1) {
                showGlobalMessage("CSV must contain 'Product Title' and 'Main Image URL' columns.", 'error');
                batchProcessBtn.disabled = false;
                batchProcessBtn.querySelector('span').textContent = translations[currentLanguage].btn_start_batch;
                return;
            }

            const rows = data.slice(1);

            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                const rowData = {
                    productName: row[productNameIndex],
                    productDescription: productDescriptionIndex > -1 ? row[productDescriptionIndex] : '',
                    imageUrl: row[imageUrlIndex]
                };

                if (!rowData.productName || !rowData.imageUrl) {
                    console.warn(`Skipping row ${i + 1} due to missing product name or image URL.`);
                    continue;
                }
                
                const settings = {
                    apiKey: userApiKey,
                    language: languageSelect.value,
                    voice: voiceSelect.value,
                    category: categorySelect.options[categorySelect.selectedIndex].text,
                    style: styleSelect.value
                };

                await createAndRunBatchJob(rowData, settings, i + 1);
            }
            
            batchProcessBtn.disabled = false;
            batchProcessBtn.querySelector('span').textContent = translations[currentLanguage].btn_start_batch;
            downloadAllMp4Btn.disabled = false;
            showGlobalMessage(translations[currentLanguage].batch_complete, 'success');
        }
        
        async function createAndRunBatchJob(rowData, settings, rowNum) {
            const { productName, productDescription, imageUrl } = rowData;
            const jobId = Date.now() + rowNum;
            const job = { 
                id: jobId, 
                topic: productName, 
                status: 'pending', 
                style: settings.style,
                imageUrl: imageUrl, // Store the original URL for later use
                isBatch: true // Flag this as a batch job
            };
            videoJobs.push(job);
            const card = createNewCard(jobId);
            videoCardsContainer.appendChild(card);

            try {
                // 1. Generate Script (pass image URL to be analyzed by AI)
                updateCardUI(job.id, { title: job.topic, status: `Fetching image for row ${rowNum}...` });
                const imageBase64 = await imageUrlToBase64(imageUrl);

                // 2. Generate Script
                updateCardUI(job.id, { status: translations[currentLanguage].status_generating_script });
                const scriptData = await generateUGCScript(productName, productDescription, [imageBase64], settings.language);
                if (!scriptData || !scriptData.script_variations || scriptData.script_variations.length === 0) {
                    throw new Error(translations[currentLanguage].error_script_format);
                }
                job.scriptData = scriptData;
                
                // 3. Auto-select first script and generate media
                const firstVariation = scriptData.script_variations[0];
                await generateMediaForJob(job.id, firstVariation.script_text, firstVariation.title, imageUrl);

            } catch(error) {
                console.error(`Error processing row ${rowNum} (${productName}):`, error);
                job.status = 'error';
                updateCardUI(job.id, { status: `${translations[currentLanguage].error_processing_row} ${rowNum}: ${error.message}`, error: true });
            }
        }

        async function imageUrlToBase64(url) {
            // Basic URL validation
            if (!url || typeof url !== 'string' || !url.trim().startsWith('http')) {
                throw new Error(`Invalid URL provided: "${url}"`);
            }
            
            try {
                // Attempt a direct fetch. Many image hosts might block this due to CORS.
                const response = await fetch(url.trim());
                if (!response.ok) {
                    throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
                }
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error(`Failed to fetch or process image from ${url}. Error: ${error.message}`);
                throw new Error(`Could not fetch image. It might be a network issue or the site may be blocking requests (CORS).`);
            }
        }

        function parseCSV(csvText) {
            const rows = [];
            let row = [];
            let field = '';
            let inQuotes = false;
            let i = 0;
            if (csvText.charCodeAt(0) === 0xFEFF) i = 1;
            for (; i < csvText.length; i++) {
                const char = csvText[i];
                if (inQuotes) {
                    if (char === '"') {
                        if (i + 1 < csvText.length && csvText[i + 1] === '"') {
                            field += '"'; i++;
                        } else {
                            inQuotes = false;
                        }
                    } else {
                        field += char;
                    }
                } else {
                    if (char === '"') {
                        if (field === '') inQuotes = true;
                        else field += char;
                    } else if (char === ',') {
                        row.push(field); field = '';
                    } else if (char === '\n' || char === '\r') {
                        row.push(field); rows.push(row);
                        row = []; field = '';
                        if (char === '\r' && i + 1 < csvText.length && csvText[i + 1] === '\n') i++;
                    } else {
                        field += char;
                    }
                }
            }
            if (field || row.length > 0) {
                row.push(field); rows.push(row);
            }
            return rows.filter(row => row.some(field => field.trim() !== ''));
        }
        
        async function autoRenderAndDownload(jobId) {
            const job = videoJobs.find(j => j.id === jobId);
            if (!job) return;

            try {
                updateCardUI(job.id, { status: 'Auto-rendering WebM...' });

                await preloadImages(job);

                const webmBlob = await renderAndProceed('auto_download_webm', job);

                if (webmBlob && webmBlob.size > 0) {
                    const videoUrl = URL.createObjectURL(webmBlob);
                    const tempLink = document.createElement('a');
                    tempLink.href = videoUrl;
                    tempLink.download = `${job.topic.trim().replace(/\s/g, '_')}.webm`;
                    document.body.appendChild(tempLink);
                    tempLink.click();
                    document.body.removeChild(tempLink);
                    URL.revokeObjectURL(videoUrl);

                    job.downloaded = true;
                    updateCardUI(job.id, { status: '‚úÖ WebM Downloaded', ready: true });
                } else {
                    throw new Error("Rendered blob was empty.");
                }
            } catch (error) {
                console.error(`Auto-render failed for job ${job.id}:`, error);
                updateCardUI(job.id, { status: '‚ùå Auto-render failed', ready: true });
            }
        }

        // --- Bulk Download MP4 Logic ---

        async function renderAndConvertToMp4(job) {
            updateCardUI(job.id, { status: 'Rendering for MP4 conversion...' });
            
            // Step 1: Render the job to a WebM blob
            await preloadImages(job);
            const webmBlob = await renderAndProceed('download_mp4', job);
            if (!webmBlob) {
                throw new Error("Failed to render WebM video.");
            }
            
            updateCardUI(job.id, { status: 'Converting to MP4... Please wait.' });

            // Step 2: Send to conversion API
            const formData = new FormData();
            formData.append("file", webmBlob, `${job.topic.replace(/\s/g, '_')}.webm`);
            
            const res = await fetch("https://videoconvert-production.up.railway.app/api/convert", {
                method: "POST",
                body: formData
            });

            const data = await res.json();

            if (data.success) {
                const downloadUrl = "https://videoconvert-production.up.railway.app" + data.download_url;
                updateCardUI(job.id, { status: '‚úÖ MP4 Ready!' });
                return { downloadUrl, job };
            } else {
                throw new Error("Conversion API failed.");
            }
        }

        downloadAllMp4Btn.addEventListener('click', async () => {
            const readyJobs = videoJobs.filter(j => j.status === 'ready');
            if (readyJobs.length === 0) {
                showGlobalMessage("No videos are ready to be downloaded.", "error");
                return;
            }

            downloadAllMp4Btn.disabled = true;
            downloadAllMp4Btn.querySelector('span').textContent = "Converting...";

            for (const job of readyJobs) {
                try {
                    const { downloadUrl, job: finishedJob } = await renderAndConvertToMp4(job);
                    
                    // Trigger download
                    const a = document.createElement("a");
                    a.href = downloadUrl;
                    a.download = `${finishedJob.topic.trim().replace(/\s/g, '_')}.mp4`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // Add a small delay between downloads to prevent browser blocking
                    await new Promise(resolve => setTimeout(resolve, 1000)); 

                } catch (error) {
                    console.error(`Failed to convert job ${job.id}:`, error);
                    updateCardUI(job.id, { status: `‚ùå MP4 Conversion Failed`, error: true });
                }
            }

            downloadAllMp4Btn.querySelector('span').textContent = "Download All as MP4";
            showGlobalMessage("All MP4 conversions are complete!", "success");
        });


    </script>
</body>
</html>
